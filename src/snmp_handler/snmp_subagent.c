/*
 * Note: this file originally auto-generated by mib2c
 * using subagent.m2c
 */
/* standard Net-SNMP includes */
#include "log.h"
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

/* include our parent header */
#include "utils.h"
#include "driverModule.h"
#include "channel_data.h"
#include "coord_data.h"
#include "kgmdedectormodulestatus.h"
#include "signal_state_data.h"
#include "user_data.h"

#include "global_config_data.h"
#include "global_time_data.h"

#include "cabinet_1202_data.h"
#include "phase_parameter.h"
#include "detector_parameters_data.h"
#include "channel_data_1202.h"
#include "volume_occupancy_data.h"
// #include "unit_parameters_data.h"



/*
 * If compiling within the net-snmp source code, this will trigger the feature
 * detection mechansim to ensure the agent_check_and_process() function
 * is left available even if --enable-minimialist is turned on.  If you
 * have configured net-snmp using --enable-minimialist and want to compile
 * this code externally to the Net-SNMP code base, then please add
 * --with-features="agent_check_and_process enable_stderrlog" to your
 * configure line.
 */
netsnmp_feature_require(agent_check_and_process);
netsnmp_feature_require(enable_stderrlog);
void check_traps();

static int keep_running;

void stop_snmp_server(int a) {
    keep_running = 0;
}

static void usage(void) {
   printf("usage: coord [-D<tokens>] [-f] [-L] [-M] [-H] [LISTENING ADDRESSES]\n"
          "\t-f      Do not fork() from the calling shell.\n"
          "\t-DTOKEN[,TOKEN,...]\n"
          "\t\tTurn on debugging output for the given TOKEN(s).\n"
          "\t\tWithout any tokens specified, it defaults to printing\n"
          "\t\tall the tokens (which is equivalent to the keyword 'ALL').\n"
          "\t\tYou might want to try ALL for extremely verbose output.\n"
          "\t\tNote: You can't put a space between the -D and the TOKENs.\n"
          "\t-H\tDisplay a list of configuration file directives\n"
          "\t\tunderstood by the agent and then exit.\n"
          "\t-M\tRun as a normal SNMP Agent instead of an AgentX sub-agent.\n"
          "\t-x ADDRESS\tconnect to master agent at ADDRESS (default /var/agentx/master).\n"
          "\t-L\tDo not open a log file; print all messages to stderr.\n");
  exit(0);
}


void* init_snmp_subagent (void* args) {
  int argc    = ((ARGS*)args)->argc;
  char **argv = ((ARGS*)args)->argv;

  int agentx_subagent=1; /* change this if you want to be a SNMP master agent */
  /* Defs for arg-handling code: handles setting of policy-related variables */
  int          ch;
  extern char *optarg;
  int dont_fork = 1, use_syslog = 0;
  char *agentx_socket = NULL;

  while ((ch = getopt(argc, argv, "D:fHLM-:x:")) != EOF)
    switch(ch) {
    case '-':
        if (strcasecmp(optarg, "help") == 0) {
            usage();
        }
        handle_long_opt(optarg);
        break;
    case 'D':
      debug_register_tokens(optarg);
      snmp_set_do_debugging(1);
      break;
    case 'f':
      dont_fork = 0;
      break;
    case 'H':
      netsnmp_ds_set_boolean(NETSNMP_DS_APPLICATION_ID, 
	                     NETSNMP_DS_AGENT_NO_ROOT_ACCESS, 1);
      init_agent("myAgent");        /* register our .conf handlers */

      init_snmp("myAgent");
      fprintf(stderr, "Configuration directives understood:\n");
      read_config_print_usage("  ");
      exit(0);
    case 'M':
      agentx_subagent = 0;
      break;
    case 'L':
      use_syslog = 0; /* use stderr */
      break;
    case 'x':
      agentx_socket = optarg;
      break;
    default:
      fprintf(stderr,"unknown option %c\n", ch);
      usage();
  }

  if (optind < argc) {
      int i;
      /*
       * There are optional transport addresses on the command line.  
       */
      DEBUGMSGTL(("snmpd/main", "optind %d, argc %d\n", optind, argc));
      for (i = optind; i < argc; i++) {
          char *c, *astring;
          if ((c = netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID, 
                                         NETSNMP_DS_AGENT_PORTS))) {
              astring = malloc(strlen(c) + 2 + strlen(argv[i]));
              if (astring == NULL) {
                  fprintf(stderr, "malloc failure processing argv[%d]\n", i);
                  exit(1);
              }
              sprintf(astring, "%s,%s", c, argv[i]);
              netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
                                    NETSNMP_DS_AGENT_PORTS, astring);
              SNMP_FREE(astring);
          } else {
              netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID, 
                                    NETSNMP_DS_AGENT_PORTS, argv[i]);
          }
      }
      DEBUGMSGTL(("snmpd/main", "port spec: %s\n",
                  netsnmp_ds_get_string(NETSNMP_DS_APPLICATION_ID, 
                                        NETSNMP_DS_AGENT_PORTS)));
  }

  /* we're an agentx subagent? */
  if (agentx_subagent) {
    /* make us a agentx client. */
    netsnmp_enable_subagent();
    if (NULL != agentx_socket)
        netsnmp_ds_set_string(NETSNMP_DS_APPLICATION_ID,
                              NETSNMP_DS_AGENT_X_SOCKET, agentx_socket);
  }

  snmp_disable_log();
  if (use_syslog)
      snmp_enable_calllog();
  else
      snmp_enable_stderrlog();

  /* initialize tcp/ip if necessary */
  SOCK_STARTUP;
  
  /* initialize the agent library */
  init_agent("myAgent");

  // /* init driver module */
  init_driverModule();

  // /* init channel */
  init_channel();
  init_trafficLightFaultStatusTable();
  init_ChannelGeneralFaultStateTable();
  init_channelErrorFlagsTable();

  /* init coord */
  init_coord();  
  init_trPatternTable();
  
  /* Detector */
  init_kgmDedectorModuleStatus();

  /* Signal state*/
  init_signalState();
  init_signalStateTable();

  /* User*/
  init_user();
  init_userOperationsTable();

  // /* Global Configuration */
  // init_globalConfiguration();
  // init_globalModuleTable();

  /* Global Time Management */
  init_globalTimeManagement();
  // init_customTimeBaseDayPlanTable();
  // init_customTimeBaseScheduleTable();
  // init_customSpecialDayTable();
  // init_dstTable();

  // /* 1202 Cabinet Env */
  init_cabinetEnvironment();
  init_cabinetEnvironDevicesTable();

  // /* Phase Parameters */
  init_phase();
  init_phaseStatusGroupTable();

  // /* Detector Parameters */
  init_detector_1202();
  init_vehicleDetectorStatusGroupTable();
  init_pedestrianDetectorStatusGroupTable();
  init_vehicleDetectorTable();
  init_pedestrianDetectorTable();
  init_vehicleDetectorControlGroupTable();
  init_pedestrianDetectorControlGroupTable();
  /* Volume Occupancy Report */
  init_volumeOccupancyReport();
  init_volumeOccupancyTable();

  // /* 1202 Channel Parameters */
  init_channel_1202();
  // init_channelStatusGroupTable();

  /* Unit Parameters */
  // init_unit();

  /* read coord.conf files. */
  init_snmp("myAgent");

  /* If we're going to be a snmp master agent, initial the ports */
  if (!agentx_subagent)
    init_master_agent();  /* open the port to listen on (defaults to udp:161) */

  /* In case we recevie a request to stop (kill -TERM or kill -INT) */
  keep_running = 1;
  // signal(SIGTERM, stop_server);
  // signal(SIGINT, stop_server);

  if(user_login() == 0)
    log_error("Unauthorized User Access \n");

  /* you're main loop here... */
  while(keep_running) {
    /* if you use select(), see snmp_select_info() in snmp_api(3) */
    /*     --- OR ---  */
    int status = agent_check_and_process(0); /* 0 == don't block */
    if(status == -1)
      log_error("agent_check_and_process fail");
    check_traps();
    usleep(5*1000);
  }

  /* at shutdown time */
  snmp_shutdown("myAgent");
  SOCK_CLEANUP;
}

static time_t start_time = 0;

void check_traps(){
  static int trap_state = 0;
  
  time_t cur_time  = clock();
  double time_diff = difftime(cur_time, start_time) / CLOCKS_PER_SEC; 

  if(time_diff < SNMP_TRAP_CHECK_INTERVAL_SEC)
    return; 

  start_time = cur_time;

  switch (trap_state)
  {
  case 0:
    check_cabinet_traps();
    trap_state = 1;
    break;

  case 1:
    check_signal_state_exec_mode_trap();
    trap_state = 2;
    break;
  
  case 2:
    check_channel_traps();
    trap_state = 3;
    break;

  case 3:
    check_driverModule_traps();
    check_dedectorModule_traps();
    trap_state = 0;
    break;

  default:
    trap_state = 0;
    break;
  }
}