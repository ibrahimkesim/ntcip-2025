/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-set.m2c
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "pedestrianDetectorTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table pedestrianDetectorTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * NTCIP1202-v03::pedestrianDetectorTable is subid 7 of detector.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * pedestrianDetectorTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * pedestrianDetectorTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
pedestrianDetectorTable_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup pedestrianDetectorTable undo.
     * set up pedestrianDetectorTable undo information, in preparation for a set.
     * Undo storage is in (* pedestrianDetectorOptions_val_ptr )*
     */

    return rc;
} /* pedestrianDetectorTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
pedestrianDetectorTable_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> pedestrianDetectorTable undo.
     * pedestrianDetectorTable undo information, in response to a failed set.
     * Undo storage is in (* pedestrianDetectorOptions_val_ptr )*
     */

    return rc;
} /* pedestrianDetectorTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
pedestrianDetectorTable_undo_cleanup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup pedestrianDetectorTable undo.
     * Undo storage is in (* pedestrianDetectorOptions_val_ptr )*
     */

    return rc;
} /* pedestrianDetectorTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * pedestrianDetectorTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param pedestrianDetectorTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
pedestrianDetectorTable_commit( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit pedestrianDetectorTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_PEDESTRIANDETECTORCALLPHASE_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANDETECTORCALLPHASE_FLAG; /* clear pedestrianDetectorCallPhase */
       /*
        * TODO:482:o: |-> commit column pedestrianDetectorCallPhase.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianDetectorCallPhase commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianDetectorCallPhase
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANDETECTORCALLPHASE_FLAG;
       }
    }

    if (save_flags & COLUMN_PEDESTRIANDETECTORNOACTIVITY_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANDETECTORNOACTIVITY_FLAG; /* clear pedestrianDetectorNoActivity */
       /*
        * TODO:482:o: |-> commit column pedestrianDetectorNoActivity.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianDetectorNoActivity commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianDetectorNoActivity
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANDETECTORNOACTIVITY_FLAG;
       }
    }

    if (save_flags & COLUMN_PEDESTRIANDETECTORMAXPRESENCE_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANDETECTORMAXPRESENCE_FLAG; /* clear pedestrianDetectorMaxPresence */
       /*
        * TODO:482:o: |-> commit column pedestrianDetectorMaxPresence.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianDetectorMaxPresence commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianDetectorMaxPresence
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANDETECTORMAXPRESENCE_FLAG;
       }
    }

    if (save_flags & COLUMN_PEDESTRIANDETECTORERRATICCOUNTS_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANDETECTORERRATICCOUNTS_FLAG; /* clear pedestrianDetectorErraticCounts */
       /*
        * TODO:482:o: |-> commit column pedestrianDetectorErraticCounts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianDetectorErraticCounts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianDetectorErraticCounts
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANDETECTORERRATICCOUNTS_FLAG;
       }
    }

    if (save_flags & COLUMN_PEDESTRIANDETECTORRESET_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANDETECTORRESET_FLAG; /* clear pedestrianDetectorReset */
       /*
        * TODO:482:o: |-> commit column pedestrianDetectorReset.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianDetectorReset commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianDetectorReset
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANDETECTORRESET_FLAG;
       }
    }

    if (save_flags & COLUMN_PEDESTRIANBUTTONPUSHTIME_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANBUTTONPUSHTIME_FLAG; /* clear pedestrianButtonPushTime */
       /*
        * TODO:482:o: |-> commit column pedestrianButtonPushTime.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianButtonPushTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianButtonPushTime
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANBUTTONPUSHTIME_FLAG;
       }
    }

    if (save_flags & COLUMN_PEDESTRIANDETECTOROPTIONS_FLAG) {
       save_flags &= ~COLUMN_PEDESTRIANDETECTOROPTIONS_FLAG; /* clear pedestrianDetectorOptions */
       /*
        * TODO:482:o: |-> commit column pedestrianDetectorOptions.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"pedestrianDetectorTable column pedestrianDetectorOptions commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo pedestrianDetectorOptions
             */
            rowreq_ctx->column_set_flags |= COLUMN_PEDESTRIANDETECTOROPTIONS_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* pedestrianDetectorTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * pedestrianDetectorTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param pedestrianDetectorTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
pedestrianDetectorTable_undo_commit( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo pedestrianDetectorTable commit.
     * check each column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANDETECTORCALLPHASE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANDETECTORNOACTIVITY_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANDETECTORMAXPRESENCE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANDETECTORERRATICCOUNTS_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANDETECTORRESET_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANBUTTONPUSHTIME_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PEDESTRIANDETECTOROPTIONS_FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* pedestrianDetectorTable_undo_commit */

/*
 * TODO:440:M: Implement pedestrianDetectorTable node value checks.
 * TODO:450:M: Implement pedestrianDetectorTable undo functions.
 * TODO:460:M: Implement pedestrianDetectorTable set functions.
 * TODO:480:M: Implement pedestrianDetectorTable commit functions.
 */
/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianDetectorCallPhase
 * pedestrianDetectorCallPhase is subid 2 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.2
 * Description:
<Definition> This object contains assigned phase number
for the pedestrian detector input associated with this row. The
associated detector call capability is enabled when this object
is set to a non-zero value. The value shall not exceed the value
of maxPhases.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.2
<Unit> phase
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianDetectorCallPhase_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianDetectorCallPhase_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorCallPhase_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorCallPhase_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianDetectorCallPhase value.
     */

    return MFD_SUCCESS; /* pedestrianDetectorCallPhase value not illegal */
} /* pedestrianDetectorCallPhase_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianDetectorCallPhase_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorCallPhase_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianDetectorCallPhase undo.
     */
    /*
     * copy pedestrianDetectorCallPhase data
     * set rowreq_ctx->undo->pedestrianDetectorCallPhase from rowreq_ctx->data.pedestrianDetectorCallPhase
     */
    rowreq_ctx->undo->pedestrianDetectorCallPhase = rowreq_ctx->data.pedestrianDetectorCallPhase;


    return MFD_SUCCESS;
} /* pedestrianDetectorCallPhase_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianDetectorCallPhase_val
 *        A long containing the new value.
 */
int
pedestrianDetectorCallPhase_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorCallPhase_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorCallPhase_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianDetectorCallPhase value.
     * set pedestrianDetectorCallPhase value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianDetectorCallPhase = pedestrianDetectorCallPhase_val;

    return MFD_SUCCESS;
} /* pedestrianDetectorCallPhase_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianDetectorCallPhase_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorCallPhase_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianDetectorCallPhase undo.
     */
    /*
     * copy pedestrianDetectorCallPhase data
     * set rowreq_ctx->data.pedestrianDetectorCallPhase from rowreq_ctx->undo->pedestrianDetectorCallPhase
     */
    rowreq_ctx->data.pedestrianDetectorCallPhase = rowreq_ctx->undo->pedestrianDetectorCallPhase;

    
    return MFD_SUCCESS;
} /* pedestrianDetectorCallPhase_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianDetectorNoActivity
 * pedestrianDetectorNoActivity is subid 3 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.3
 * Description:
<Definition> Pedestrian Detector No Activity diagnostic
Parameter in minutes (0�255 min.). If an active detector does not
exhibit an actuation in the specified period, it is considered a
fault by the diagnostics and the detector is classified as
Failed. A value of 0 for this object shall disable this
diagnostic for this detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.3
<Unit> minute
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianDetectorNoActivity_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianDetectorNoActivity_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorNoActivity_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorNoActivity_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianDetectorNoActivity value.
     */

    return MFD_SUCCESS; /* pedestrianDetectorNoActivity value not illegal */
} /* pedestrianDetectorNoActivity_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianDetectorNoActivity_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorNoActivity_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianDetectorNoActivity undo.
     */
    /*
     * copy pedestrianDetectorNoActivity data
     * set rowreq_ctx->undo->pedestrianDetectorNoActivity from rowreq_ctx->data.pedestrianDetectorNoActivity
     */
    rowreq_ctx->undo->pedestrianDetectorNoActivity = rowreq_ctx->data.pedestrianDetectorNoActivity;


    return MFD_SUCCESS;
} /* pedestrianDetectorNoActivity_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianDetectorNoActivity_val
 *        A long containing the new value.
 */
int
pedestrianDetectorNoActivity_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorNoActivity_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorNoActivity_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianDetectorNoActivity value.
     * set pedestrianDetectorNoActivity value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianDetectorNoActivity = pedestrianDetectorNoActivity_val;

    return MFD_SUCCESS;
} /* pedestrianDetectorNoActivity_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianDetectorNoActivity_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorNoActivity_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianDetectorNoActivity undo.
     */
    /*
     * copy pedestrianDetectorNoActivity data
     * set rowreq_ctx->data.pedestrianDetectorNoActivity from rowreq_ctx->undo->pedestrianDetectorNoActivity
     */
    rowreq_ctx->data.pedestrianDetectorNoActivity = rowreq_ctx->undo->pedestrianDetectorNoActivity;

    
    return MFD_SUCCESS;
} /* pedestrianDetectorNoActivity_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianDetectorMaxPresence
 * pedestrianDetectorMaxPresence is subid 4 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.4
 * Description:
<Definition> Pedestrian Detector Maximum Presence
diagnostic Parameter in minutes (0-255 min.). If an active
detector exhibits continuous detection for too long a period, it
is considered a fault by the diagnostics and the detector is
classified as Failed. A value of 0 for this object shall disable
this diagnostic for this detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.4
<Unit> minute
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianDetectorMaxPresence_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianDetectorMaxPresence_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorMaxPresence_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorMaxPresence_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianDetectorMaxPresence value.
     */

    return MFD_SUCCESS; /* pedestrianDetectorMaxPresence value not illegal */
} /* pedestrianDetectorMaxPresence_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianDetectorMaxPresence_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorMaxPresence_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianDetectorMaxPresence undo.
     */
    /*
     * copy pedestrianDetectorMaxPresence data
     * set rowreq_ctx->undo->pedestrianDetectorMaxPresence from rowreq_ctx->data.pedestrianDetectorMaxPresence
     */
    rowreq_ctx->undo->pedestrianDetectorMaxPresence = rowreq_ctx->data.pedestrianDetectorMaxPresence;


    return MFD_SUCCESS;
} /* pedestrianDetectorMaxPresence_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianDetectorMaxPresence_val
 *        A long containing the new value.
 */
int
pedestrianDetectorMaxPresence_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorMaxPresence_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorMaxPresence_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianDetectorMaxPresence value.
     * set pedestrianDetectorMaxPresence value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianDetectorMaxPresence = pedestrianDetectorMaxPresence_val;

    return MFD_SUCCESS;
} /* pedestrianDetectorMaxPresence_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianDetectorMaxPresence_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorMaxPresence_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianDetectorMaxPresence undo.
     */
    /*
     * copy pedestrianDetectorMaxPresence data
     * set rowreq_ctx->data.pedestrianDetectorMaxPresence from rowreq_ctx->undo->pedestrianDetectorMaxPresence
     */
    rowreq_ctx->data.pedestrianDetectorMaxPresence = rowreq_ctx->undo->pedestrianDetectorMaxPresence;

    
    return MFD_SUCCESS;
} /* pedestrianDetectorMaxPresence_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianDetectorErraticCounts
 * pedestrianDetectorErraticCounts is subid 5 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.5
 * Description:
<Definition> Pedestrian Detector Erratic Counts diagnostic
Parameter in counts/minute (0-255 cpm). If an active detector
exhibits excessive actuations, it is considered a fault by the
diagnostics and the detector is classified as Failed. A value of
0 for this object shall disable this diagnostic for this
detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.5
<Unit> count
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianDetectorErraticCounts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianDetectorErraticCounts_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorErraticCounts_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorErraticCounts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianDetectorErraticCounts value.
     */

    return MFD_SUCCESS; /* pedestrianDetectorErraticCounts value not illegal */
} /* pedestrianDetectorErraticCounts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianDetectorErraticCounts_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorErraticCounts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianDetectorErraticCounts undo.
     */
    /*
     * copy pedestrianDetectorErraticCounts data
     * set rowreq_ctx->undo->pedestrianDetectorErraticCounts from rowreq_ctx->data.pedestrianDetectorErraticCounts
     */
    rowreq_ctx->undo->pedestrianDetectorErraticCounts = rowreq_ctx->data.pedestrianDetectorErraticCounts;


    return MFD_SUCCESS;
} /* pedestrianDetectorErraticCounts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianDetectorErraticCounts_val
 *        A long containing the new value.
 */
int
pedestrianDetectorErraticCounts_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorErraticCounts_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorErraticCounts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianDetectorErraticCounts value.
     * set pedestrianDetectorErraticCounts value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianDetectorErraticCounts = pedestrianDetectorErraticCounts_val;

    return MFD_SUCCESS;
} /* pedestrianDetectorErraticCounts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianDetectorErraticCounts_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorErraticCounts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianDetectorErraticCounts undo.
     */
    /*
     * copy pedestrianDetectorErraticCounts data
     * set rowreq_ctx->data.pedestrianDetectorErraticCounts from rowreq_ctx->undo->pedestrianDetectorErraticCounts
     */
    rowreq_ctx->data.pedestrianDetectorErraticCounts = rowreq_ctx->undo->pedestrianDetectorErraticCounts;

    
    return MFD_SUCCESS;
} /* pedestrianDetectorErraticCounts_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianDetectorReset
 * pedestrianDetectorReset is subid 7 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.7
 * Description:
<Definition> This object when set to TRUE (one) shall
cause the CU to command the associated detector to reset. This
object shall automatically return to FALSE (zero) after the CU
has issued the reset command.
Note: this may affect other detector (detector channels) that are
physically attached to a common reset line.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.7
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 1;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianDetectorReset_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 1
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianDetectorReset_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorReset_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorReset_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianDetectorReset value.
     */

    return MFD_SUCCESS; /* pedestrianDetectorReset value not illegal */
} /* pedestrianDetectorReset_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianDetectorReset_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorReset_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianDetectorReset undo.
     */
    /*
     * copy pedestrianDetectorReset data
     * set rowreq_ctx->undo->pedestrianDetectorReset from rowreq_ctx->data.pedestrianDetectorReset
     */
    rowreq_ctx->undo->pedestrianDetectorReset = rowreq_ctx->data.pedestrianDetectorReset;


    return MFD_SUCCESS;
} /* pedestrianDetectorReset_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianDetectorReset_val
 *        A long containing the new value.
 */
int
pedestrianDetectorReset_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorReset_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorReset_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianDetectorReset value.
     * set pedestrianDetectorReset value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianDetectorReset = pedestrianDetectorReset_val;

    return MFD_SUCCESS;
} /* pedestrianDetectorReset_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianDetectorReset_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorReset_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianDetectorReset undo.
     */
    /*
     * copy pedestrianDetectorReset data
     * set rowreq_ctx->data.pedestrianDetectorReset from rowreq_ctx->undo->pedestrianDetectorReset
     */
    rowreq_ctx->data.pedestrianDetectorReset = rowreq_ctx->undo->pedestrianDetectorReset;

    
    return MFD_SUCCESS;
} /* pedestrianDetectorReset_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianButtonPushTime
 * pedestrianButtonPushTime is subid 8 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.8
 * Description:
<Definition> The minimum amount of time, in tenths of a
second, a pedestrian call button is pressed to actuate additional
accessible features such as increased pedestrian crossing times
(phasePedAlternateWalk) or pedestrian clearance times
(phasePedAlternateClearance). A value of 0 indicates that all
accessible pedestrian signal (APS) features are disabled for the
associated detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.8
<Unit> tenth of a second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianButtonPushTime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianButtonPushTime_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianButtonPushTime_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianButtonPushTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianButtonPushTime value.
     */

    return MFD_SUCCESS; /* pedestrianButtonPushTime value not illegal */
} /* pedestrianButtonPushTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianButtonPushTime_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianButtonPushTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianButtonPushTime undo.
     */
    /*
     * copy pedestrianButtonPushTime data
     * set rowreq_ctx->undo->pedestrianButtonPushTime from rowreq_ctx->data.pedestrianButtonPushTime
     */
    rowreq_ctx->undo->pedestrianButtonPushTime = rowreq_ctx->data.pedestrianButtonPushTime;


    return MFD_SUCCESS;
} /* pedestrianButtonPushTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianButtonPushTime_val
 *        A long containing the new value.
 */
int
pedestrianButtonPushTime_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianButtonPushTime_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianButtonPushTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianButtonPushTime value.
     * set pedestrianButtonPushTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianButtonPushTime = pedestrianButtonPushTime_val;

    return MFD_SUCCESS;
} /* pedestrianButtonPushTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianButtonPushTime_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianButtonPushTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianButtonPushTime undo.
     */
    /*
     * copy pedestrianButtonPushTime data
     * set rowreq_ctx->data.pedestrianButtonPushTime from rowreq_ctx->undo->pedestrianButtonPushTime
     */
    rowreq_ctx->data.pedestrianButtonPushTime = rowreq_ctx->undo->pedestrianButtonPushTime;

    
    return MFD_SUCCESS;
} /* pedestrianButtonPushTime_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::pedestrianDetectorEntry.pedestrianDetectorOptions
 * pedestrianDetectorOptions is subid 9 of pedestrianDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.7.1.9
 * Description:
 <Definition> Pedestrian Detector Options Parameter as
follows (0=Disabled, 1=Enabled):
Bit 7: Reserved.
Bit 6: Reserved.
Bit 5: Reserved.
Bit 4: Reserved.
Bit 3: Reserved.
Bit 2: Non-locking: If enabled, detector will place a non-locked
calls instead  of a locked calls.
Bit 1: Alternate timing: If enabled, detector will place calls
for alternate ped timing instead of normal ped timing.
Bit 0: Presence: If enabled, detector indicates presence of
pedestrians in the crosswalk instead of placing calls for
service.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.7.1.9
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pedestrianDetectorOptions_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * pedestrianDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
pedestrianDetectorOptions_check_value( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorOptions_val)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorOptions_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid pedestrianDetectorOptions value.
     */

    return MFD_SUCCESS; /* pedestrianDetectorOptions value not illegal */
} /* pedestrianDetectorOptions_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (pedestrianDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * pedestrianDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
pedestrianDetectorOptions_undo_setup( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorOptions_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup pedestrianDetectorOptions undo.
     */
    /*
     * copy pedestrianDetectorOptions data
     * set rowreq_ctx->undo->pedestrianDetectorOptions from rowreq_ctx->data.pedestrianDetectorOptions
     */
    rowreq_ctx->undo->pedestrianDetectorOptions = rowreq_ctx->data.pedestrianDetectorOptions;


    return MFD_SUCCESS;
} /* pedestrianDetectorOptions_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param pedestrianDetectorOptions_val
 *        A long containing the new value.
 */
int
pedestrianDetectorOptions_set( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx, long pedestrianDetectorOptions_val )
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorOptions_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set pedestrianDetectorOptions value.
     * set pedestrianDetectorOptions value in rowreq_ctx->data
     */
    rowreq_ctx->data.pedestrianDetectorOptions = pedestrianDetectorOptions_val;

    return MFD_SUCCESS;
} /* pedestrianDetectorOptions_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
pedestrianDetectorOptions_undo( pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:pedestrianDetectorTable:pedestrianDetectorOptions_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up pedestrianDetectorOptions undo.
     */
    /*
     * copy pedestrianDetectorOptions data
     * set rowreq_ctx->data.pedestrianDetectorOptions from rowreq_ctx->undo->pedestrianDetectorOptions
     */
    rowreq_ctx->data.pedestrianDetectorOptions = rowreq_ctx->undo->pedestrianDetectorOptions;

    
    return MFD_SUCCESS;
} /* pedestrianDetectorOptions_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * pedestrianDetectorTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-pedestrianDetectorTable if you don't have dependencies)
 */
int
pedestrianDetectorTable_check_dependencies(pedestrianDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:pedestrianDetectorTable:pedestrianDetectorTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check pedestrianDetectorTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    return rc;
} /* pedestrianDetectorTable_check_dependencies */

/** @} */
