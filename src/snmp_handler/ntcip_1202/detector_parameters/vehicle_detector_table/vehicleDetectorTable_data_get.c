/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-get.m2c
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "vehicleDetectorTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement vehicleDetectorTable get routines.
 * TODO:240:M: Implement vehicleDetectorTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table vehicleDetectorTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * NTCIP1202-v03::vehicleDetectorTable is subid 2 of detector.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement vehicleDetectorTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param vehicleDetectorNumber_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
vehicleDetectorTable_indexes_set_tbl_idx(vehicleDetectorTable_mib_index *tbl_idx, long vehicleDetectorNumber_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_indexes_set_tbl_idx","called\n"));

    /* vehicleDetectorNumber(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
    tbl_idx->vehicleDetectorNumber = vehicleDetectorNumber_val;
    

    return MFD_SUCCESS;
} /* vehicleDetectorTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
vehicleDetectorTable_indexes_set(vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorNumber_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_indexes_set","called\n"));

    if(MFD_SUCCESS != vehicleDetectorTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , vehicleDetectorNumber_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != vehicleDetectorTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* vehicleDetectorTable_indexes_set */


/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorOptions
 * vehicleDetectorOptions is subid 2 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.2
 * Description:
<Definition> Vehicle Detector Options Parameter as follows
(0=Disabled, 1=Enabled):
Bit 7: Call - if Enabled, the CU shall place a demand for
vehicular service on the assigned phase when the phase is
not timing the green interval and an actuation is present.
Bit 6: Queue - if Enabled, the CU shall extend the green interval
of the assigned phase until a gap occurs (no actuation) or
until the green has been active longer than the
vehicleDetectorQueueLimit time. This is optional.
Bit 5: AddedInitial - if Enabled, the CU shall accumulate
detector actuation counts for use in the added initial
calculations. Counts shall be accumulated from the
beginning of the yellow interval to the beginning of the
green interval.
Bit 4: Passage - if Enabled, the CU shall maintain a reset to the
associated phase passage timer for the duration of the
detector actuation when the phase is green.
Bit 3: Red Lock Call - if Enabled, the detector will lock a call
to the assigned phase if an actuation occurs while the
phase is not timing Green or Yellow. This mode is optional.
Bit 2: Yellow Lock Call - if Enabled, the detector will lock a
call to the assigned phase if an actuation occurs while the
phase is not timing Green.
Bit 1: Occupancy Detector - if Enabled, the detector collects
data for the associated detector occupancy object(s). This
capability may not be supported on all detector inputs to a
device.
Bit 0: Volume Detector - if Enabled, the detector collects data
for the associated detector volume object(s). This

capability may not be supported on all detector inputs to a
device.
A SET of both bits 2 & 3 = 1 shall result in bit 2=1 and bit 3=0.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.2
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorOptions data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorOptions_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorOptions_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorOptions_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorOptions_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorOptions data.
 * copy (* vehicleDetectorOptions_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorOptions_val_ptr ) = rowreq_ctx->data.vehicleDetectorOptions;

    return MFD_SUCCESS;
} /* vehicleDetectorOptions_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorCallPhase
 * vehicleDetectorCallPhase is subid 4 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.4
 * Description:
<Definition> This object contains assigned phase number
for the detector input associated with this row. The associated
detector call capability is enabled when this object is set to a
non-zero value. The value shall not exceed the value of
maxPhases.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.4
<Unit> phase
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorCallPhase data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorCallPhase_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorCallPhase_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorCallPhase_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorCallPhase_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorCallPhase_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorCallPhase data.
 * copy (* vehicleDetectorCallPhase_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorCallPhase_val_ptr ) = rowreq_ctx->data.vehicleDetectorCallPhase;

    return MFD_SUCCESS;
} /* vehicleDetectorCallPhase_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorSwitchPhase
 * vehicleDetectorSwitchPhase is subid 5 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.5
 * Description:
<Definition> Detector Switch Phase Parameter (i.e., Phase
Number). The phase to which a vehicle detector actuation shall be
switched when the assigned phase is Yellow or Red and the Switch
Phase is Green.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.5
<Unit> phase
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorSwitchPhase data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorSwitchPhase_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorSwitchPhase_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorSwitchPhase_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorSwitchPhase_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorSwitchPhase_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorSwitchPhase data.
 * copy (* vehicleDetectorSwitchPhase_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorSwitchPhase_val_ptr ) = rowreq_ctx->data.vehicleDetectorSwitchPhase;

    return MFD_SUCCESS;
} /* vehicleDetectorSwitchPhase_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorDelay
 * vehicleDetectorDelay is subid 6 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.6
 * Description:
<Definition> Detector Delay Parameter in tenth seconds (0�
255.0 sec). The period a detector actuation (input recognition)
shall be delayed when the phase is not Green. If a management
station attempts to set a value between 2551 and 65535,
inclusive, the parameter is undefined.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.6
<Unit> tenth second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorDelay data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorDelay_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorDelay_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorDelay_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorDelay_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorDelay_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorDelay data.
 * copy (* vehicleDetectorDelay_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorDelay_val_ptr ) = rowreq_ctx->data.vehicleDetectorDelay;

    return MFD_SUCCESS;
} /* vehicleDetectorDelay_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorExtend
 * vehicleDetectorExtend is subid 7 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.7
 * Description:
<Definition> Detector Extend Parameter in tenth seconds
(0�25.5 sec). The period a vehicle detector actuation (input
duration) shall be extended from the point of termination, when
the phase is Green.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.7
<Unit> tenth second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorExtend data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorExtend_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorExtend_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorExtend_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorExtend_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorExtend_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorExtend data.
 * copy (* vehicleDetectorExtend_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorExtend_val_ptr ) = rowreq_ctx->data.vehicleDetectorExtend;

    return MFD_SUCCESS;
} /* vehicleDetectorExtend_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorQueueLimit
 * vehicleDetectorQueueLimit is subid 8 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.8
 * Description:
<Definition> Detector Queue Limit parameter in seconds
(0-255 sec). The length of time that an actuation from a queue
detector may continue into the phase green. This time begins when
the phase becomes green and when it expires any associated
detector inputs shall be ignored. This time may be shorter due to
other overriding device parameters (i.e. Maximum time, Force
Offs, ...).
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.8
<Unit> second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorQueueLimit data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorQueueLimit_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorQueueLimit_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorQueueLimit_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorQueueLimit_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorQueueLimit_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorQueueLimit data.
 * copy (* vehicleDetectorQueueLimit_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorQueueLimit_val_ptr ) = rowreq_ctx->data.vehicleDetectorQueueLimit;

    return MFD_SUCCESS;
} /* vehicleDetectorQueueLimit_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorNoActivity
 * vehicleDetectorNoActivity is subid 9 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.9
 * Description:
<Definition> Detector No Activity diagnostic Parameter in
minutes (0�255 min.). If an active detector does not exhibit an
actuation in the specified period, it is considered a fault by
the diagnostics and the detector is classified as Failed. A value
of 0 for this object shall disable this diagnostic for this
detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.9
<Unit> minute
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorNoActivity data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorNoActivity_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorNoActivity_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorNoActivity_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorNoActivity_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorNoActivity_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorNoActivity data.
 * copy (* vehicleDetectorNoActivity_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorNoActivity_val_ptr ) = rowreq_ctx->data.vehicleDetectorNoActivity;

    return MFD_SUCCESS;
} /* vehicleDetectorNoActivity_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorMaxPresence
 * vehicleDetectorMaxPresence is subid 10 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.10
 * Description:
<Definition> Detector Maximum Presence diagnostic
Parameter in minutes (0-255 min.). If an active detector exhibits

continuous detection for too long a period, it is considered a
fault by the diagnostics and the detector is classified as
Failed. A value of 0 for this object shall disable this
diagnostic for this detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.10
<Unit> minute
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorMaxPresence data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorMaxPresence_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorMaxPresence_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorMaxPresence_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorMaxPresence_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorMaxPresence_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorMaxPresence data.
 * copy (* vehicleDetectorMaxPresence_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorMaxPresence_val_ptr ) = rowreq_ctx->data.vehicleDetectorMaxPresence;

    return MFD_SUCCESS;
} /* vehicleDetectorMaxPresence_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorErraticCounts
 * vehicleDetectorErraticCounts is subid 11 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.11
 * Description:
<Definition> Detector Erratic Counts diagnostic Parameter
in counts/minute (0-255 cpm). If an active detector exhibits
excessive actuations, it is considered a fault by the diagnostics
and the detector is classified as Failed. A value of 0 for this
object shall disable this diagnostic for this detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.11
<Unit> count
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorErraticCounts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorErraticCounts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorErraticCounts_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorErraticCounts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorErraticCounts_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorErraticCounts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorErraticCounts data.
 * copy (* vehicleDetectorErraticCounts_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorErraticCounts_val_ptr ) = rowreq_ctx->data.vehicleDetectorErraticCounts;

    return MFD_SUCCESS;
} /* vehicleDetectorErraticCounts_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorFailTime
 * vehicleDetectorFailTime is subid 12 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.12
 * Description:
<Definition> Detector Fail Time in seconds (0..255 sec).
If a detector diagnostic indicates that the associated detector
input is failed, then a call shall be placed on the associated
phase during all non-green intervals. When each green interval
begins the call shall be maintained for the length of time
specified by this object and then removed. If the value of this
object equals the maximum value (255) then a constant call shall
be placed on the associated phase (max recall). If the value of
this object equals zero then no call shall be placed on the
associated phase for any interval (no recall). Compliant devices
may support a limited capability for this object (i.e. only max
recall or max recall and no recall). At a minimum the max recall
setting must be supported.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.12
<Unit> second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorFailTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorFailTime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorFailTime_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorFailTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorFailTime_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorFailTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorFailTime data.
 * copy (* vehicleDetectorFailTime_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorFailTime_val_ptr ) = rowreq_ctx->data.vehicleDetectorFailTime;

    return MFD_SUCCESS;
} /* vehicleDetectorFailTime_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorAlarms
 * vehicleDetectorAlarms is subid 13 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.13
 * Description:
<Definition> This object shall return indications of
detector alarms. Detector Alarms are indicated as follows:

Bit 7: Other Fault - The detector has failed due to some other
cause.
Bit 6: Reserved.
Bit 5: Reserved.
Bit 4: Configuration Fault - Detector is assigned but is not
supported.
Bit 3: Communications Fault - Communications to the device (if
present) have failed.
Bit 2: Erratic Output Fault - This detector has been flagged as
non-operational due to erratic outputs (excessive counts)
by the CU detector diagnostic.
Bit 1: Max Presence Fault - This detector has been flagged as
non-operational due to a presence indicator that exceeded
the maximum expected time by the CU detector diagnostic.
Bit 0: No Activity Fault - This detector has been flagged as non-
operational due to lower than expected activity by the CU
detector diagnostic.
Once set a bit shall maintain its state as long as the condition
exists. The bit shall clear when the condition no longer exists.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.13
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorAlarms data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorAlarms_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorAlarms_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorAlarms_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorAlarms_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorAlarms_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorAlarms data.
 * copy (* vehicleDetectorAlarms_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorAlarms_val_ptr ) = rowreq_ctx->data.vehicleDetectorAlarms;

    return MFD_SUCCESS;
} /* vehicleDetectorAlarms_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorReportedAlarms
 * vehicleDetectorReportedAlarms is subid 14 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.14
 * Description:
<Definition> This object shall return detector device
reported alarms (via some communications mechanism). Inductive
Loop Detector Alarms are indicated as follows:
Bit 7: Reserved.
Bit 6: Reserved.
Bit 5: Reserved.
Bit 4: Excessive Change Fault - This detector has been flagged as
non-operational due to an inductance change that exceeded
expected values.
Bit 3: Shorted Loop Fault - This detector has been flagged as
non-operational due to a shorted loop wire.
Bit 2: Open Loop Fault - This detector has been flagged as non-
operational due to an open loop (broken wire).
Bit 1: Watchdog Fault - This detector has been flagged as non-
operational due to a watchdog error.
Bit 0: Other - This detector has been flagged as non-operational
due to some other error.
Once set a bit shall maintain its state as long as the condition
exists. The bit shall clear when the condition no longer exists.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.14
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorReportedAlarms data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorReportedAlarms_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorReportedAlarms_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorReportedAlarms_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorReportedAlarms_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorReportedAlarms_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorReportedAlarms data.
 * copy (* vehicleDetectorReportedAlarms_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorReportedAlarms_val_ptr ) = rowreq_ctx->data.vehicleDetectorReportedAlarms;

    return MFD_SUCCESS;
} /* vehicleDetectorReportedAlarms_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorReset
 * vehicleDetectorReset is subid 15 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.15
 * Description:
<Definition> This object when set to TRUE (one) shall
cause the CU to command the associated detector to reset. This
object shall automatically return to FALSE (zero) after the CU
has issued the reset command.
Note: this may affect other detector (detector channels) that are
physically attached to a common reset line.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 1;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorReset data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorReset_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorReset_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorReset_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorReset_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorReset_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorReset data.
 * copy (* vehicleDetectorReset_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorReset_val_ptr ) = rowreq_ctx->data.vehicleDetectorReset;

    return MFD_SUCCESS;
} /* vehicleDetectorReset_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorOptions2
 * vehicleDetectorOptions2 is subid 16 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.16
 * Description:
<Definition> A bit-mapped value as defined below for
configuring detector options.
<Format>
bits 7-3 Reserved.
bit 2   0=CUSTOM, 1=NTCIP  Default Detector Speed Mode Option. For a
vehicle detector operating in pairs, this option
is used when there is an error on one of the
paired detectors. It identifies how the controller
should calculate speed without the other detector.
CUSTOM indicates a manufacturer specific
calculation. NTCIP indicates the use of the
calculation Speed = (Average Vehicle Length +
Detector Length) / Detect Time.
bit 1   0=TRAIL, 1=LEAD  Detector Placement Option. For a vehicle
detector operating in pairs, this option indicates
the leading and trailing detectors. LEAD indicates
that the detector is the leading detector of the
pair. TRAIL indicates that the detector is a
trailing detector in the pair.
bit 0   0=DISABLED, 1=ENABLED
Speed Detector. If enabled, the detector is used
to collect speed data (See volumeOccupancyTable
and detectorAvgSpeed). This capability may not be
supported on all detector inputs to a device.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorOptions2 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorOptions2_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorOptions2_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorOptions2_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorOptions2_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions2_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorOptions2 data.
 * copy (* vehicleDetectorOptions2_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorOptions2_val_ptr ) = rowreq_ctx->data.vehicleDetectorOptions2;

    return MFD_SUCCESS;
} /* vehicleDetectorOptions2_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorPairedDetector
 * vehicleDetectorPairedDetector is subid 17 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.17
 * Description:
<Definition> This is a detector identifier
(vehicleDetectorNumber) that is used to determine speed. A value
of 0 indicates there is no paired detector. Setting this value
will automatically add this detector as the given detector's
vehicleDetectorPairedDetector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.17
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorPairedDetector data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorPairedDetector_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorPairedDetector_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorPairedDetector_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorPairedDetector_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetector_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorPairedDetector data.
 * copy (* vehicleDetectorPairedDetector_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorPairedDetector_val_ptr ) = rowreq_ctx->data.vehicleDetectorPairedDetector;

    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetector_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorPairedDetectorSpacing
 * vehicleDetectorPairedDetectorSpacing is subid 18 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.18
 * Description:
<Definition> This parameter allows the user to set the
spacing, in 0.01 meters, between paired detectors for use in
calculating vehicle speeds. This parameter is measured from the
leading edge of one detector to the leading edge of the paired
detector. A value of 0 indicates there is no paired detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.18
<unit> one-hundredth of a meter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorPairedDetectorSpacing data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorPairedDetectorSpacing_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorPairedDetectorSpacing_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorPairedDetectorSpacing_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorPairedDetectorSpacing_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetectorSpacing_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorPairedDetectorSpacing data.
 * copy (* vehicleDetectorPairedDetectorSpacing_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorPairedDetectorSpacing_val_ptr ) = rowreq_ctx->data.vehicleDetectorPairedDetectorSpacing;

    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetectorSpacing_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorAvgVehicleLength
 * vehicleDetectorAvgVehicleLength is subid 19 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.19
 * Description:
<Definition> This parameter allows the user to set the
average vehicle length for use in determining speed and
classification. This allows for a range of lengths between 0.01
meters to 40 meters in length.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.19
<Unit> one-hundredth of a meter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 4000;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorAvgVehicleLength data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorAvgVehicleLength_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorAvgVehicleLength_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorAvgVehicleLength_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorAvgVehicleLength_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorAvgVehicleLength_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorAvgVehicleLength data.
 * copy (* vehicleDetectorAvgVehicleLength_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorAvgVehicleLength_val_ptr ) = rowreq_ctx->data.vehicleDetectorAvgVehicleLength;

    return MFD_SUCCESS;
} /* vehicleDetectorAvgVehicleLength_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorLength
 * vehicleDetectorLength is subid 20 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.20
 * Description:
<Definition> This parameter allows the user to set the
length of the detection zone. In the case of a loop detector,
this is the length of the loop.
<Valid Value Rule> Values 01 to 4000 are used to represent the length.
This allows for a range of lengths between 0.01 meters to 40
meters in length. The value of 65535 shall be returned to
represent no length set. Values 4001 to 65534 are not used.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.20
<Unit> one-hundredth of a meter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 65535
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the vehicleDetectorLength data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorLength_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorLength_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long * vehicleDetectorLength_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorLength_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorLength_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorLength data.
 * copy (* vehicleDetectorLength_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorLength_val_ptr ) = rowreq_ctx->data.vehicleDetectorLength;

    return MFD_SUCCESS;
} /* vehicleDetectorLength_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorTravelMode
 * vehicleDetectorTravelMode is subid 21 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.21
 * Description:
<Definition> This parameter allows the user to identify
detectors for specific types of travel modes.
other: refers to a detector for a travel type not defined in this
standard
vehicle: refers to a detector identified for vehicles.
transit: refers to a detector identified for transit vehicles.
bicycle: refers to a detector identified for bicycles.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.21
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: vehicle
 *
 * Enum range: 4. Values:  other(1), vehicle(2), transit(3), bicycle(4)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the vehicleDetectorTravelMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorTravelMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
vehicleDetectorTravelMode_get( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, u_long * vehicleDetectorTravelMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != vehicleDetectorTravelMode_val_ptr );


    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTravelMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the vehicleDetectorTravelMode data.
 * copy (* vehicleDetectorTravelMode_val_ptr ) from rowreq_ctx->data
 */
    (* vehicleDetectorTravelMode_val_ptr ) = rowreq_ctx->data.vehicleDetectorTravelMode;

    return MFD_SUCCESS;
} /* vehicleDetectorTravelMode_get */



/** @} */
