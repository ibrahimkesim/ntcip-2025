/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-set.m2c
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "vehicleDetectorTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table vehicleDetectorTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * NTCIP1202-v03::vehicleDetectorTable is subid 2 of detector.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * vehicleDetectorTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * vehicleDetectorTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
vehicleDetectorTable_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup vehicleDetectorTable undo.
     * set up vehicleDetectorTable undo information, in preparation for a set.
     * Undo storage is in (* vehicleDetectorTravelMode_val_ptr )*
     */

    return rc;
} /* vehicleDetectorTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
vehicleDetectorTable_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> vehicleDetectorTable undo.
     * vehicleDetectorTable undo information, in response to a failed set.
     * Undo storage is in (* vehicleDetectorTravelMode_val_ptr )*
     */

    return rc;
} /* vehicleDetectorTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
vehicleDetectorTable_undo_cleanup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup vehicleDetectorTable undo.
     * Undo storage is in (* vehicleDetectorTravelMode_val_ptr )*
     */

    return rc;
} /* vehicleDetectorTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * vehicleDetectorTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param vehicleDetectorTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
vehicleDetectorTable_commit( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit vehicleDetectorTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_VEHICLEDETECTOROPTIONS_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTOROPTIONS_FLAG; /* clear vehicleDetectorOptions */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorOptions.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorOptions commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorOptions
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTOROPTIONS_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORCALLPHASE_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORCALLPHASE_FLAG; /* clear vehicleDetectorCallPhase */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorCallPhase.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorCallPhase commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorCallPhase
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORCALLPHASE_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORSWITCHPHASE_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORSWITCHPHASE_FLAG; /* clear vehicleDetectorSwitchPhase */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorSwitchPhase.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorSwitchPhase commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorSwitchPhase
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORSWITCHPHASE_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORDELAY_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORDELAY_FLAG; /* clear vehicleDetectorDelay */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorDelay.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorDelay commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorDelay
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORDELAY_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTOREXTEND_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTOREXTEND_FLAG; /* clear vehicleDetectorExtend */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorExtend.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorExtend commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorExtend
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTOREXTEND_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORQUEUELIMIT_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORQUEUELIMIT_FLAG; /* clear vehicleDetectorQueueLimit */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorQueueLimit.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorQueueLimit commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorQueueLimit
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORQUEUELIMIT_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORNOACTIVITY_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORNOACTIVITY_FLAG; /* clear vehicleDetectorNoActivity */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorNoActivity.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorNoActivity commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorNoActivity
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORNOACTIVITY_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORMAXPRESENCE_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORMAXPRESENCE_FLAG; /* clear vehicleDetectorMaxPresence */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorMaxPresence.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorMaxPresence commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorMaxPresence
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORMAXPRESENCE_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORERRATICCOUNTS_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORERRATICCOUNTS_FLAG; /* clear vehicleDetectorErraticCounts */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorErraticCounts.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorErraticCounts commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorErraticCounts
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORERRATICCOUNTS_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORFAILTIME_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORFAILTIME_FLAG; /* clear vehicleDetectorFailTime */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorFailTime.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorFailTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorFailTime
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORFAILTIME_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORRESET_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORRESET_FLAG; /* clear vehicleDetectorReset */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorReset.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorReset commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorReset
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORRESET_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTOROPTIONS2_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTOROPTIONS2_FLAG; /* clear vehicleDetectorOptions2 */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorOptions2.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorOptions2 commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorOptions2
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTOROPTIONS2_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORPAIREDDETECTOR_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORPAIREDDETECTOR_FLAG; /* clear vehicleDetectorPairedDetector */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorPairedDetector.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorPairedDetector commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorPairedDetector
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORPAIREDDETECTOR_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORPAIREDDETECTORSPACING_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORPAIREDDETECTORSPACING_FLAG; /* clear vehicleDetectorPairedDetectorSpacing */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorPairedDetectorSpacing.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorPairedDetectorSpacing commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorPairedDetectorSpacing
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORPAIREDDETECTORSPACING_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORAVGVEHICLELENGTH_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORAVGVEHICLELENGTH_FLAG; /* clear vehicleDetectorAvgVehicleLength */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorAvgVehicleLength.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorAvgVehicleLength commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorAvgVehicleLength
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORAVGVEHICLELENGTH_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORLENGTH_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORLENGTH_FLAG; /* clear vehicleDetectorLength */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorLength.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorLength commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorLength
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORLENGTH_FLAG;
       }
    }

    if (save_flags & COLUMN_VEHICLEDETECTORTRAVELMODE_FLAG) {
       save_flags &= ~COLUMN_VEHICLEDETECTORTRAVELMODE_FLAG; /* clear vehicleDetectorTravelMode */
       /*
        * TODO:482:o: |-> commit column vehicleDetectorTravelMode.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"vehicleDetectorTable column vehicleDetectorTravelMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo vehicleDetectorTravelMode
             */
            rowreq_ctx->column_set_flags |= COLUMN_VEHICLEDETECTORTRAVELMODE_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* vehicleDetectorTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * vehicleDetectorTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param vehicleDetectorTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
vehicleDetectorTable_undo_commit( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo vehicleDetectorTable commit.
     * check each column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTOROPTIONS_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORCALLPHASE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORSWITCHPHASE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORDELAY_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTOREXTEND_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORQUEUELIMIT_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORNOACTIVITY_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORMAXPRESENCE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORERRATICCOUNTS_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORFAILTIME_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORRESET_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTOROPTIONS2_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORPAIREDDETECTOR_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORPAIREDDETECTORSPACING_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORAVGVEHICLELENGTH_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORLENGTH_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_VEHICLEDETECTORTRAVELMODE_FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* vehicleDetectorTable_undo_commit */

/*
 * TODO:440:M: Implement vehicleDetectorTable node value checks.
 * TODO:450:M: Implement vehicleDetectorTable undo functions.
 * TODO:460:M: Implement vehicleDetectorTable set functions.
 * TODO:480:M: Implement vehicleDetectorTable commit functions.
 */
/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorOptions
 * vehicleDetectorOptions is subid 2 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.2
 * Description:
<Definition> Vehicle Detector Options Parameter as follows
(0=Disabled, 1=Enabled):
Bit 7: Call - if Enabled, the CU shall place a demand for
vehicular service on the assigned phase when the phase is
not timing the green interval and an actuation is present.
Bit 6: Queue - if Enabled, the CU shall extend the green interval
of the assigned phase until a gap occurs (no actuation) or
until the green has been active longer than the
vehicleDetectorQueueLimit time. This is optional.
Bit 5: AddedInitial - if Enabled, the CU shall accumulate
detector actuation counts for use in the added initial
calculations. Counts shall be accumulated from the
beginning of the yellow interval to the beginning of the
green interval.
Bit 4: Passage - if Enabled, the CU shall maintain a reset to the
associated phase passage timer for the duration of the
detector actuation when the phase is green.
Bit 3: Red Lock Call - if Enabled, the detector will lock a call
to the assigned phase if an actuation occurs while the
phase is not timing Green or Yellow. This mode is optional.
Bit 2: Yellow Lock Call - if Enabled, the detector will lock a
call to the assigned phase if an actuation occurs while the
phase is not timing Green.
Bit 1: Occupancy Detector - if Enabled, the detector collects
data for the associated detector occupancy object(s). This
capability may not be supported on all detector inputs to a
device.
Bit 0: Volume Detector - if Enabled, the detector collects data
for the associated detector volume object(s). This

capability may not be supported on all detector inputs to a
device.
A SET of both bits 2 & 3 = 1 shall result in bit 2=1 and bit 3=0.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.2
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorOptions_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorOptions_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorOptions_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorOptions value.
     */

    return MFD_SUCCESS; /* vehicleDetectorOptions value not illegal */
} /* vehicleDetectorOptions_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorOptions_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorOptions undo.
     */
    /*
     * copy vehicleDetectorOptions data
     * set rowreq_ctx->undo->vehicleDetectorOptions from rowreq_ctx->data.vehicleDetectorOptions
     */
    rowreq_ctx->undo->vehicleDetectorOptions = rowreq_ctx->data.vehicleDetectorOptions;


    return MFD_SUCCESS;
} /* vehicleDetectorOptions_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorOptions_val
 *        A long containing the new value.
 */
int
vehicleDetectorOptions_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorOptions_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorOptions value.
     * set vehicleDetectorOptions value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorOptions = vehicleDetectorOptions_val;

    return MFD_SUCCESS;
} /* vehicleDetectorOptions_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorOptions_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorOptions undo.
     */
    /*
     * copy vehicleDetectorOptions data
     * set rowreq_ctx->data.vehicleDetectorOptions from rowreq_ctx->undo->vehicleDetectorOptions
     */
    rowreq_ctx->data.vehicleDetectorOptions = rowreq_ctx->undo->vehicleDetectorOptions;

    
    return MFD_SUCCESS;
} /* vehicleDetectorOptions_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorCallPhase
 * vehicleDetectorCallPhase is subid 4 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.4
 * Description:
<Definition> This object contains assigned phase number
for the detector input associated with this row. The associated
detector call capability is enabled when this object is set to a
non-zero value. The value shall not exceed the value of
maxPhases.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.4
<Unit> phase
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorCallPhase_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorCallPhase_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorCallPhase_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorCallPhase_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorCallPhase value.
     */

    return MFD_SUCCESS; /* vehicleDetectorCallPhase value not illegal */
} /* vehicleDetectorCallPhase_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorCallPhase_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorCallPhase_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorCallPhase undo.
     */
    /*
     * copy vehicleDetectorCallPhase data
     * set rowreq_ctx->undo->vehicleDetectorCallPhase from rowreq_ctx->data.vehicleDetectorCallPhase
     */
    rowreq_ctx->undo->vehicleDetectorCallPhase = rowreq_ctx->data.vehicleDetectorCallPhase;


    return MFD_SUCCESS;
} /* vehicleDetectorCallPhase_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorCallPhase_val
 *        A long containing the new value.
 */
int
vehicleDetectorCallPhase_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorCallPhase_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorCallPhase_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorCallPhase value.
     * set vehicleDetectorCallPhase value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorCallPhase = vehicleDetectorCallPhase_val;

    return MFD_SUCCESS;
} /* vehicleDetectorCallPhase_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorCallPhase_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorCallPhase_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorCallPhase undo.
     */
    /*
     * copy vehicleDetectorCallPhase data
     * set rowreq_ctx->data.vehicleDetectorCallPhase from rowreq_ctx->undo->vehicleDetectorCallPhase
     */
    rowreq_ctx->data.vehicleDetectorCallPhase = rowreq_ctx->undo->vehicleDetectorCallPhase;

    
    return MFD_SUCCESS;
} /* vehicleDetectorCallPhase_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorSwitchPhase
 * vehicleDetectorSwitchPhase is subid 5 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.5
 * Description:
<Definition> Detector Switch Phase Parameter (i.e., Phase
Number). The phase to which a vehicle detector actuation shall be
switched when the assigned phase is Yellow or Red and the Switch
Phase is Green.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.5
<Unit> phase
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorSwitchPhase_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorSwitchPhase_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorSwitchPhase_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorSwitchPhase_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorSwitchPhase value.
     */

    return MFD_SUCCESS; /* vehicleDetectorSwitchPhase value not illegal */
} /* vehicleDetectorSwitchPhase_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorSwitchPhase_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorSwitchPhase_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorSwitchPhase undo.
     */
    /*
     * copy vehicleDetectorSwitchPhase data
     * set rowreq_ctx->undo->vehicleDetectorSwitchPhase from rowreq_ctx->data.vehicleDetectorSwitchPhase
     */
    rowreq_ctx->undo->vehicleDetectorSwitchPhase = rowreq_ctx->data.vehicleDetectorSwitchPhase;


    return MFD_SUCCESS;
} /* vehicleDetectorSwitchPhase_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorSwitchPhase_val
 *        A long containing the new value.
 */
int
vehicleDetectorSwitchPhase_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorSwitchPhase_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorSwitchPhase_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorSwitchPhase value.
     * set vehicleDetectorSwitchPhase value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorSwitchPhase = vehicleDetectorSwitchPhase_val;

    return MFD_SUCCESS;
} /* vehicleDetectorSwitchPhase_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorSwitchPhase_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorSwitchPhase_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorSwitchPhase undo.
     */
    /*
     * copy vehicleDetectorSwitchPhase data
     * set rowreq_ctx->data.vehicleDetectorSwitchPhase from rowreq_ctx->undo->vehicleDetectorSwitchPhase
     */
    rowreq_ctx->data.vehicleDetectorSwitchPhase = rowreq_ctx->undo->vehicleDetectorSwitchPhase;

    
    return MFD_SUCCESS;
} /* vehicleDetectorSwitchPhase_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorDelay
 * vehicleDetectorDelay is subid 6 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.6
 * Description:
<Definition> Detector Delay Parameter in tenth seconds (0�
255.0 sec). The period a detector actuation (input recognition)
shall be delayed when the phase is not Green. If a management
station attempts to set a value between 2551 and 65535,
inclusive, the parameter is undefined.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.6
<Unit> tenth second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorDelay_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorDelay_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorDelay_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorDelay_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorDelay value.
     */

    return MFD_SUCCESS; /* vehicleDetectorDelay value not illegal */
} /* vehicleDetectorDelay_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorDelay_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorDelay_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorDelay undo.
     */
    /*
     * copy vehicleDetectorDelay data
     * set rowreq_ctx->undo->vehicleDetectorDelay from rowreq_ctx->data.vehicleDetectorDelay
     */
    rowreq_ctx->undo->vehicleDetectorDelay = rowreq_ctx->data.vehicleDetectorDelay;


    return MFD_SUCCESS;
} /* vehicleDetectorDelay_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorDelay_val
 *        A long containing the new value.
 */
int
vehicleDetectorDelay_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorDelay_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorDelay_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorDelay value.
     * set vehicleDetectorDelay value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorDelay = vehicleDetectorDelay_val;

    return MFD_SUCCESS;
} /* vehicleDetectorDelay_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorDelay_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorDelay_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorDelay undo.
     */
    /*
     * copy vehicleDetectorDelay data
     * set rowreq_ctx->data.vehicleDetectorDelay from rowreq_ctx->undo->vehicleDetectorDelay
     */
    rowreq_ctx->data.vehicleDetectorDelay = rowreq_ctx->undo->vehicleDetectorDelay;

    
    return MFD_SUCCESS;
} /* vehicleDetectorDelay_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorExtend
 * vehicleDetectorExtend is subid 7 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.7
 * Description:
<Definition> Detector Extend Parameter in tenth seconds
(0�25.5 sec). The period a vehicle detector actuation (input
duration) shall be extended from the point of termination, when
the phase is Green.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.7
<Unit> tenth second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorExtend_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorExtend_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorExtend_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorExtend_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorExtend value.
     */

    return MFD_SUCCESS; /* vehicleDetectorExtend value not illegal */
} /* vehicleDetectorExtend_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorExtend_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorExtend_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorExtend undo.
     */
    /*
     * copy vehicleDetectorExtend data
     * set rowreq_ctx->undo->vehicleDetectorExtend from rowreq_ctx->data.vehicleDetectorExtend
     */
    rowreq_ctx->undo->vehicleDetectorExtend = rowreq_ctx->data.vehicleDetectorExtend;


    return MFD_SUCCESS;
} /* vehicleDetectorExtend_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorExtend_val
 *        A long containing the new value.
 */
int
vehicleDetectorExtend_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorExtend_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorExtend_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorExtend value.
     * set vehicleDetectorExtend value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorExtend = vehicleDetectorExtend_val;

    return MFD_SUCCESS;
} /* vehicleDetectorExtend_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorExtend_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorExtend_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorExtend undo.
     */
    /*
     * copy vehicleDetectorExtend data
     * set rowreq_ctx->data.vehicleDetectorExtend from rowreq_ctx->undo->vehicleDetectorExtend
     */
    rowreq_ctx->data.vehicleDetectorExtend = rowreq_ctx->undo->vehicleDetectorExtend;

    
    return MFD_SUCCESS;
} /* vehicleDetectorExtend_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorQueueLimit
 * vehicleDetectorQueueLimit is subid 8 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.8
 * Description:
<Definition> Detector Queue Limit parameter in seconds
(0-255 sec). The length of time that an actuation from a queue
detector may continue into the phase green. This time begins when
the phase becomes green and when it expires any associated
detector inputs shall be ignored. This time may be shorter due to
other overriding device parameters (i.e. Maximum time, Force
Offs, ...).
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.8
<Unit> second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorQueueLimit_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorQueueLimit_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorQueueLimit_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorQueueLimit_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorQueueLimit value.
     */

    return MFD_SUCCESS; /* vehicleDetectorQueueLimit value not illegal */
} /* vehicleDetectorQueueLimit_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorQueueLimit_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorQueueLimit_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorQueueLimit undo.
     */
    /*
     * copy vehicleDetectorQueueLimit data
     * set rowreq_ctx->undo->vehicleDetectorQueueLimit from rowreq_ctx->data.vehicleDetectorQueueLimit
     */
    rowreq_ctx->undo->vehicleDetectorQueueLimit = rowreq_ctx->data.vehicleDetectorQueueLimit;


    return MFD_SUCCESS;
} /* vehicleDetectorQueueLimit_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorQueueLimit_val
 *        A long containing the new value.
 */
int
vehicleDetectorQueueLimit_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorQueueLimit_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorQueueLimit_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorQueueLimit value.
     * set vehicleDetectorQueueLimit value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorQueueLimit = vehicleDetectorQueueLimit_val;

    return MFD_SUCCESS;
} /* vehicleDetectorQueueLimit_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorQueueLimit_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorQueueLimit_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorQueueLimit undo.
     */
    /*
     * copy vehicleDetectorQueueLimit data
     * set rowreq_ctx->data.vehicleDetectorQueueLimit from rowreq_ctx->undo->vehicleDetectorQueueLimit
     */
    rowreq_ctx->data.vehicleDetectorQueueLimit = rowreq_ctx->undo->vehicleDetectorQueueLimit;

    
    return MFD_SUCCESS;
} /* vehicleDetectorQueueLimit_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorNoActivity
 * vehicleDetectorNoActivity is subid 9 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.9
 * Description:
<Definition> Detector No Activity diagnostic Parameter in
minutes (0�255 min.). If an active detector does not exhibit an
actuation in the specified period, it is considered a fault by
the diagnostics and the detector is classified as Failed. A value
of 0 for this object shall disable this diagnostic for this
detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.9
<Unit> minute
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorNoActivity_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorNoActivity_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorNoActivity_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorNoActivity_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorNoActivity value.
     */

    return MFD_SUCCESS; /* vehicleDetectorNoActivity value not illegal */
} /* vehicleDetectorNoActivity_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorNoActivity_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorNoActivity_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorNoActivity undo.
     */
    /*
     * copy vehicleDetectorNoActivity data
     * set rowreq_ctx->undo->vehicleDetectorNoActivity from rowreq_ctx->data.vehicleDetectorNoActivity
     */
    rowreq_ctx->undo->vehicleDetectorNoActivity = rowreq_ctx->data.vehicleDetectorNoActivity;


    return MFD_SUCCESS;
} /* vehicleDetectorNoActivity_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorNoActivity_val
 *        A long containing the new value.
 */
int
vehicleDetectorNoActivity_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorNoActivity_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorNoActivity_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorNoActivity value.
     * set vehicleDetectorNoActivity value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorNoActivity = vehicleDetectorNoActivity_val;

    return MFD_SUCCESS;
} /* vehicleDetectorNoActivity_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorNoActivity_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorNoActivity_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorNoActivity undo.
     */
    /*
     * copy vehicleDetectorNoActivity data
     * set rowreq_ctx->data.vehicleDetectorNoActivity from rowreq_ctx->undo->vehicleDetectorNoActivity
     */
    rowreq_ctx->data.vehicleDetectorNoActivity = rowreq_ctx->undo->vehicleDetectorNoActivity;

    
    return MFD_SUCCESS;
} /* vehicleDetectorNoActivity_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorMaxPresence
 * vehicleDetectorMaxPresence is subid 10 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.10
 * Description:
<Definition> Detector Maximum Presence diagnostic
Parameter in minutes (0-255 min.). If an active detector exhibits

continuous detection for too long a period, it is considered a
fault by the diagnostics and the detector is classified as
Failed. A value of 0 for this object shall disable this
diagnostic for this detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.10
<Unit> minute
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorMaxPresence_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorMaxPresence_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorMaxPresence_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorMaxPresence_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorMaxPresence value.
     */

    return MFD_SUCCESS; /* vehicleDetectorMaxPresence value not illegal */
} /* vehicleDetectorMaxPresence_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorMaxPresence_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorMaxPresence_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorMaxPresence undo.
     */
    /*
     * copy vehicleDetectorMaxPresence data
     * set rowreq_ctx->undo->vehicleDetectorMaxPresence from rowreq_ctx->data.vehicleDetectorMaxPresence
     */
    rowreq_ctx->undo->vehicleDetectorMaxPresence = rowreq_ctx->data.vehicleDetectorMaxPresence;


    return MFD_SUCCESS;
} /* vehicleDetectorMaxPresence_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorMaxPresence_val
 *        A long containing the new value.
 */
int
vehicleDetectorMaxPresence_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorMaxPresence_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorMaxPresence_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorMaxPresence value.
     * set vehicleDetectorMaxPresence value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorMaxPresence = vehicleDetectorMaxPresence_val;

    return MFD_SUCCESS;
} /* vehicleDetectorMaxPresence_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorMaxPresence_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorMaxPresence_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorMaxPresence undo.
     */
    /*
     * copy vehicleDetectorMaxPresence data
     * set rowreq_ctx->data.vehicleDetectorMaxPresence from rowreq_ctx->undo->vehicleDetectorMaxPresence
     */
    rowreq_ctx->data.vehicleDetectorMaxPresence = rowreq_ctx->undo->vehicleDetectorMaxPresence;

    
    return MFD_SUCCESS;
} /* vehicleDetectorMaxPresence_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorErraticCounts
 * vehicleDetectorErraticCounts is subid 11 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.11
 * Description:
<Definition> Detector Erratic Counts diagnostic Parameter
in counts/minute (0-255 cpm). If an active detector exhibits
excessive actuations, it is considered a fault by the diagnostics
and the detector is classified as Failed. A value of 0 for this
object shall disable this diagnostic for this detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.11
<Unit> count
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorErraticCounts_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorErraticCounts_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorErraticCounts_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorErraticCounts_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorErraticCounts value.
     */

    return MFD_SUCCESS; /* vehicleDetectorErraticCounts value not illegal */
} /* vehicleDetectorErraticCounts_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorErraticCounts_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorErraticCounts_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorErraticCounts undo.
     */
    /*
     * copy vehicleDetectorErraticCounts data
     * set rowreq_ctx->undo->vehicleDetectorErraticCounts from rowreq_ctx->data.vehicleDetectorErraticCounts
     */
    rowreq_ctx->undo->vehicleDetectorErraticCounts = rowreq_ctx->data.vehicleDetectorErraticCounts;


    return MFD_SUCCESS;
} /* vehicleDetectorErraticCounts_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorErraticCounts_val
 *        A long containing the new value.
 */
int
vehicleDetectorErraticCounts_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorErraticCounts_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorErraticCounts_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorErraticCounts value.
     * set vehicleDetectorErraticCounts value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorErraticCounts = vehicleDetectorErraticCounts_val;

    return MFD_SUCCESS;
} /* vehicleDetectorErraticCounts_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorErraticCounts_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorErraticCounts_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorErraticCounts undo.
     */
    /*
     * copy vehicleDetectorErraticCounts data
     * set rowreq_ctx->data.vehicleDetectorErraticCounts from rowreq_ctx->undo->vehicleDetectorErraticCounts
     */
    rowreq_ctx->data.vehicleDetectorErraticCounts = rowreq_ctx->undo->vehicleDetectorErraticCounts;

    
    return MFD_SUCCESS;
} /* vehicleDetectorErraticCounts_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorFailTime
 * vehicleDetectorFailTime is subid 12 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.12
 * Description:
<Definition> Detector Fail Time in seconds (0..255 sec).
If a detector diagnostic indicates that the associated detector
input is failed, then a call shall be placed on the associated
phase during all non-green intervals. When each green interval
begins the call shall be maintained for the length of time
specified by this object and then removed. If the value of this
object equals the maximum value (255) then a constant call shall
be placed on the associated phase (max recall). If the value of
this object equals zero then no call shall be placed on the
associated phase for any interval (no recall). Compliant devices
may support a limited capability for this object (i.e. only max
recall or max recall and no recall). At a minimum the max recall
setting must be supported.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.12
<Unit> second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorFailTime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorFailTime_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorFailTime_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorFailTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorFailTime value.
     */

    return MFD_SUCCESS; /* vehicleDetectorFailTime value not illegal */
} /* vehicleDetectorFailTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorFailTime_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorFailTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorFailTime undo.
     */
    /*
     * copy vehicleDetectorFailTime data
     * set rowreq_ctx->undo->vehicleDetectorFailTime from rowreq_ctx->data.vehicleDetectorFailTime
     */
    rowreq_ctx->undo->vehicleDetectorFailTime = rowreq_ctx->data.vehicleDetectorFailTime;


    return MFD_SUCCESS;
} /* vehicleDetectorFailTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorFailTime_val
 *        A long containing the new value.
 */
int
vehicleDetectorFailTime_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorFailTime_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorFailTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorFailTime value.
     * set vehicleDetectorFailTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorFailTime = vehicleDetectorFailTime_val;

    return MFD_SUCCESS;
} /* vehicleDetectorFailTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorFailTime_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorFailTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorFailTime undo.
     */
    /*
     * copy vehicleDetectorFailTime data
     * set rowreq_ctx->data.vehicleDetectorFailTime from rowreq_ctx->undo->vehicleDetectorFailTime
     */
    rowreq_ctx->data.vehicleDetectorFailTime = rowreq_ctx->undo->vehicleDetectorFailTime;

    
    return MFD_SUCCESS;
} /* vehicleDetectorFailTime_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorReset
 * vehicleDetectorReset is subid 15 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.15
 * Description:
<Definition> This object when set to TRUE (one) shall
cause the CU to command the associated detector to reset. This
object shall automatically return to FALSE (zero) after the CU
has issued the reset command.
Note: this may affect other detector (detector channels) that are
physically attached to a common reset line.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.15
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 1;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorReset_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 1
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorReset_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorReset_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorReset_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorReset value.
     */

    return MFD_SUCCESS; /* vehicleDetectorReset value not illegal */
} /* vehicleDetectorReset_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorReset_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorReset_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorReset undo.
     */
    /*
     * copy vehicleDetectorReset data
     * set rowreq_ctx->undo->vehicleDetectorReset from rowreq_ctx->data.vehicleDetectorReset
     */
    rowreq_ctx->undo->vehicleDetectorReset = rowreq_ctx->data.vehicleDetectorReset;


    return MFD_SUCCESS;
} /* vehicleDetectorReset_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorReset_val
 *        A long containing the new value.
 */
int
vehicleDetectorReset_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorReset_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorReset_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorReset value.
     * set vehicleDetectorReset value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorReset = vehicleDetectorReset_val;

    return MFD_SUCCESS;
} /* vehicleDetectorReset_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorReset_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorReset_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorReset undo.
     */
    /*
     * copy vehicleDetectorReset data
     * set rowreq_ctx->data.vehicleDetectorReset from rowreq_ctx->undo->vehicleDetectorReset
     */
    rowreq_ctx->data.vehicleDetectorReset = rowreq_ctx->undo->vehicleDetectorReset;

    
    return MFD_SUCCESS;
} /* vehicleDetectorReset_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorOptions2
 * vehicleDetectorOptions2 is subid 16 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.16
 * Description:
<Definition> A bit-mapped value as defined below for
configuring detector options.
<Format>
bits 7-3 Reserved.
bit 2   0=CUSTOM, 1=NTCIP  Default Detector Speed Mode Option. For a
vehicle detector operating in pairs, this option
is used when there is an error on one of the
paired detectors. It identifies how the controller
should calculate speed without the other detector.
CUSTOM indicates a manufacturer specific
calculation. NTCIP indicates the use of the
calculation Speed = (Average Vehicle Length +
Detector Length) / Detect Time.
bit 1   0=TRAIL, 1=LEAD  Detector Placement Option. For a vehicle
detector operating in pairs, this option indicates
the leading and trailing detectors. LEAD indicates
that the detector is the leading detector of the
pair. TRAIL indicates that the detector is a
trailing detector in the pair.
bit 0   0=DISABLED, 1=ENABLED
Speed Detector. If enabled, the detector is used
to collect speed data (See volumeOccupancyTable
and detectorAvgSpeed). This capability may not be
supported on all detector inputs to a device.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.16
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorOptions2_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorOptions2_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorOptions2_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions2_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorOptions2 value.
     */

    return MFD_SUCCESS; /* vehicleDetectorOptions2 value not illegal */
} /* vehicleDetectorOptions2_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorOptions2_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions2_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorOptions2 undo.
     */
    /*
     * copy vehicleDetectorOptions2 data
     * set rowreq_ctx->undo->vehicleDetectorOptions2 from rowreq_ctx->data.vehicleDetectorOptions2
     */
    rowreq_ctx->undo->vehicleDetectorOptions2 = rowreq_ctx->data.vehicleDetectorOptions2;


    return MFD_SUCCESS;
} /* vehicleDetectorOptions2_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorOptions2_val
 *        A long containing the new value.
 */
int
vehicleDetectorOptions2_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorOptions2_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions2_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorOptions2 value.
     * set vehicleDetectorOptions2 value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorOptions2 = vehicleDetectorOptions2_val;

    return MFD_SUCCESS;
} /* vehicleDetectorOptions2_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorOptions2_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorOptions2_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorOptions2 undo.
     */
    /*
     * copy vehicleDetectorOptions2 data
     * set rowreq_ctx->data.vehicleDetectorOptions2 from rowreq_ctx->undo->vehicleDetectorOptions2
     */
    rowreq_ctx->data.vehicleDetectorOptions2 = rowreq_ctx->undo->vehicleDetectorOptions2;

    
    return MFD_SUCCESS;
} /* vehicleDetectorOptions2_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorPairedDetector
 * vehicleDetectorPairedDetector is subid 17 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.17
 * Description:
<Definition> This is a detector identifier
(vehicleDetectorNumber) that is used to determine speed. A value
of 0 indicates there is no paired detector. Setting this value
will automatically add this detector as the given detector's
vehicleDetectorPairedDetector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.17
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorPairedDetector_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorPairedDetector_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorPairedDetector_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetector_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorPairedDetector value.
     */

    return MFD_SUCCESS; /* vehicleDetectorPairedDetector value not illegal */
} /* vehicleDetectorPairedDetector_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorPairedDetector_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetector_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorPairedDetector undo.
     */
    /*
     * copy vehicleDetectorPairedDetector data
     * set rowreq_ctx->undo->vehicleDetectorPairedDetector from rowreq_ctx->data.vehicleDetectorPairedDetector
     */
    rowreq_ctx->undo->vehicleDetectorPairedDetector = rowreq_ctx->data.vehicleDetectorPairedDetector;


    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetector_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorPairedDetector_val
 *        A long containing the new value.
 */
int
vehicleDetectorPairedDetector_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorPairedDetector_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetector_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorPairedDetector value.
     * set vehicleDetectorPairedDetector value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorPairedDetector = vehicleDetectorPairedDetector_val;

    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetector_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorPairedDetector_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetector_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorPairedDetector undo.
     */
    /*
     * copy vehicleDetectorPairedDetector data
     * set rowreq_ctx->data.vehicleDetectorPairedDetector from rowreq_ctx->undo->vehicleDetectorPairedDetector
     */
    rowreq_ctx->data.vehicleDetectorPairedDetector = rowreq_ctx->undo->vehicleDetectorPairedDetector;

    
    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetector_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorPairedDetectorSpacing
 * vehicleDetectorPairedDetectorSpacing is subid 18 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.18
 * Description:
<Definition> This parameter allows the user to set the
spacing, in 0.01 meters, between paired detectors for use in
calculating vehicle speeds. This parameter is measured from the
leading edge of one detector to the leading edge of the paired
detector. A value of 0 indicates there is no paired detector.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.18
<unit> one-hundredth of a meter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 0
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorPairedDetectorSpacing_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorPairedDetectorSpacing_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorPairedDetectorSpacing_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetectorSpacing_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorPairedDetectorSpacing value.
     */

    return MFD_SUCCESS; /* vehicleDetectorPairedDetectorSpacing value not illegal */
} /* vehicleDetectorPairedDetectorSpacing_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorPairedDetectorSpacing_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetectorSpacing_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorPairedDetectorSpacing undo.
     */
    /*
     * copy vehicleDetectorPairedDetectorSpacing data
     * set rowreq_ctx->undo->vehicleDetectorPairedDetectorSpacing from rowreq_ctx->data.vehicleDetectorPairedDetectorSpacing
     */
    rowreq_ctx->undo->vehicleDetectorPairedDetectorSpacing = rowreq_ctx->data.vehicleDetectorPairedDetectorSpacing;


    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetectorSpacing_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorPairedDetectorSpacing_val
 *        A long containing the new value.
 */
int
vehicleDetectorPairedDetectorSpacing_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorPairedDetectorSpacing_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetectorSpacing_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorPairedDetectorSpacing value.
     * set vehicleDetectorPairedDetectorSpacing value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorPairedDetectorSpacing = vehicleDetectorPairedDetectorSpacing_val;

    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetectorSpacing_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorPairedDetectorSpacing_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorPairedDetectorSpacing_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorPairedDetectorSpacing undo.
     */
    /*
     * copy vehicleDetectorPairedDetectorSpacing data
     * set rowreq_ctx->data.vehicleDetectorPairedDetectorSpacing from rowreq_ctx->undo->vehicleDetectorPairedDetectorSpacing
     */
    rowreq_ctx->data.vehicleDetectorPairedDetectorSpacing = rowreq_ctx->undo->vehicleDetectorPairedDetectorSpacing;

    
    return MFD_SUCCESS;
} /* vehicleDetectorPairedDetectorSpacing_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorAvgVehicleLength
 * vehicleDetectorAvgVehicleLength is subid 19 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.19
 * Description:
<Definition> This parameter allows the user to set the
average vehicle length for use in determining speed and
classification. This allows for a range of lengths between 0.01
meters to 40 meters in length.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.19
<Unit> one-hundredth of a meter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 4000;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorAvgVehicleLength_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 4000
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorAvgVehicleLength_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorAvgVehicleLength_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorAvgVehicleLength_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorAvgVehicleLength value.
     */

    return MFD_SUCCESS; /* vehicleDetectorAvgVehicleLength value not illegal */
} /* vehicleDetectorAvgVehicleLength_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorAvgVehicleLength_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorAvgVehicleLength_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorAvgVehicleLength undo.
     */
    /*
     * copy vehicleDetectorAvgVehicleLength data
     * set rowreq_ctx->undo->vehicleDetectorAvgVehicleLength from rowreq_ctx->data.vehicleDetectorAvgVehicleLength
     */
    rowreq_ctx->undo->vehicleDetectorAvgVehicleLength = rowreq_ctx->data.vehicleDetectorAvgVehicleLength;


    return MFD_SUCCESS;
} /* vehicleDetectorAvgVehicleLength_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorAvgVehicleLength_val
 *        A long containing the new value.
 */
int
vehicleDetectorAvgVehicleLength_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorAvgVehicleLength_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorAvgVehicleLength_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorAvgVehicleLength value.
     * set vehicleDetectorAvgVehicleLength value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorAvgVehicleLength = vehicleDetectorAvgVehicleLength_val;

    return MFD_SUCCESS;
} /* vehicleDetectorAvgVehicleLength_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorAvgVehicleLength_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorAvgVehicleLength_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorAvgVehicleLength undo.
     */
    /*
     * copy vehicleDetectorAvgVehicleLength data
     * set rowreq_ctx->data.vehicleDetectorAvgVehicleLength from rowreq_ctx->undo->vehicleDetectorAvgVehicleLength
     */
    rowreq_ctx->data.vehicleDetectorAvgVehicleLength = rowreq_ctx->undo->vehicleDetectorAvgVehicleLength;

    
    return MFD_SUCCESS;
} /* vehicleDetectorAvgVehicleLength_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorLength
 * vehicleDetectorLength is subid 20 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.20
 * Description:
<Definition> This parameter allows the user to set the
length of the detection zone. In the case of a loop detector,
this is the length of the loop.
<Valid Value Rule> Values 01 to 4000 are used to represent the length.
This allows for a range of lengths between 0.01 meters to 40
meters in length. The value of 65535 shall be returned to
represent no length set. Values 4001 to 65534 are not used.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.20
<Unit> one-hundredth of a meter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 1
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *   defval: 65535
 *
 * Ranges:  1 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorLength_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorLength_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorLength_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorLength_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorLength value.
     */

    return MFD_SUCCESS; /* vehicleDetectorLength value not illegal */
} /* vehicleDetectorLength_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorLength_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorLength_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorLength undo.
     */
    /*
     * copy vehicleDetectorLength data
     * set rowreq_ctx->undo->vehicleDetectorLength from rowreq_ctx->data.vehicleDetectorLength
     */
    rowreq_ctx->undo->vehicleDetectorLength = rowreq_ctx->data.vehicleDetectorLength;


    return MFD_SUCCESS;
} /* vehicleDetectorLength_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorLength_val
 *        A long containing the new value.
 */
int
vehicleDetectorLength_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, long vehicleDetectorLength_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorLength_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorLength value.
     * set vehicleDetectorLength value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorLength = vehicleDetectorLength_val;

    return MFD_SUCCESS;
} /* vehicleDetectorLength_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorLength_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorLength_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorLength undo.
     */
    /*
     * copy vehicleDetectorLength data
     * set rowreq_ctx->data.vehicleDetectorLength from rowreq_ctx->undo->vehicleDetectorLength
     */
    rowreq_ctx->data.vehicleDetectorLength = rowreq_ctx->undo->vehicleDetectorLength;

    
    return MFD_SUCCESS;
} /* vehicleDetectorLength_undo */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::vehicleDetectorEntry.vehicleDetectorTravelMode
 * vehicleDetectorTravelMode is subid 21 of vehicleDetectorEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.2.2.1.21
 * Description:
<Definition> This parameter allows the user to identify
detectors for specific types of travel modes.
other: refers to a detector for a travel type not defined in this
standard
vehicle: refers to a detector identified for vehicles.
transit: refers to a detector identified for transit vehicles.
bicycle: refers to a detector identified for bicycles.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.2.2.1.21
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: vehicle
 *
 * Enum range: 4. Values:  other(1), vehicle(2), transit(3), bicycle(4)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param vehicleDetectorTravelMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * vehicleDetectorTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  other(1), vehicle(2), transit(3), bicycle(4)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
vehicleDetectorTravelMode_check_value( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, u_long vehicleDetectorTravelMode_val)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTravelMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid vehicleDetectorTravelMode value.
     */

    return MFD_SUCCESS; /* vehicleDetectorTravelMode value not illegal */
} /* vehicleDetectorTravelMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (vehicleDetectorTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * vehicleDetectorTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
vehicleDetectorTravelMode_undo_setup( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTravelMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup vehicleDetectorTravelMode undo.
     */
    /*
     * copy vehicleDetectorTravelMode data
     * set rowreq_ctx->undo->vehicleDetectorTravelMode from rowreq_ctx->data.vehicleDetectorTravelMode
     */
    rowreq_ctx->undo->vehicleDetectorTravelMode = rowreq_ctx->data.vehicleDetectorTravelMode;


    return MFD_SUCCESS;
} /* vehicleDetectorTravelMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param vehicleDetectorTravelMode_val
 *        A long containing the new value.
 */
int
vehicleDetectorTravelMode_set( vehicleDetectorTable_rowreq_ctx *rowreq_ctx, u_long vehicleDetectorTravelMode_val )
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTravelMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set vehicleDetectorTravelMode value.
     * set vehicleDetectorTravelMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.vehicleDetectorTravelMode = vehicleDetectorTravelMode_val;

    return MFD_SUCCESS;
} /* vehicleDetectorTravelMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
vehicleDetectorTravelMode_undo( vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:vehicleDetectorTable:vehicleDetectorTravelMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up vehicleDetectorTravelMode undo.
     */
    /*
     * copy vehicleDetectorTravelMode data
     * set rowreq_ctx->data.vehicleDetectorTravelMode from rowreq_ctx->undo->vehicleDetectorTravelMode
     */
    rowreq_ctx->data.vehicleDetectorTravelMode = rowreq_ctx->undo->vehicleDetectorTravelMode;

    
    return MFD_SUCCESS;
} /* vehicleDetectorTravelMode_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * vehicleDetectorTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-vehicleDetectorTable if you don't have dependencies)
 */
int
vehicleDetectorTable_check_dependencies(vehicleDetectorTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:vehicleDetectorTable:vehicleDetectorTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check vehicleDetectorTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    return rc;
} /* vehicleDetectorTable_check_dependencies */

/** @} */
