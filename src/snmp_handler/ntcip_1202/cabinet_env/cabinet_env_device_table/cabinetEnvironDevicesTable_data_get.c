/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-get.m2c
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "cabinetEnvironDevicesTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement cabinetEnvironDevicesTable get routines.
 * TODO:240:M: Implement cabinetEnvironDevicesTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table cabinetEnvironDevicesTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * NTCIP1202-v03::cabinetEnvironDevicesTable is subid 2 of cabinetEnvironment.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.1206.4.2.1.12.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement cabinetEnvironDevicesTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param cabinetEnvironDeviceNumber_val
 * @param cabinetEnvironDeviceIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
cabinetEnvironDevicesTable_indexes_set_tbl_idx(cabinetEnvironDevicesTable_mib_index *tbl_idx, long cabinetEnvironDeviceNumber_val, long cabinetEnvironDeviceIndex_val)
{
    DEBUGMSGTL(("verbose:cabinetEnvironDevicesTable:cabinetEnvironDevicesTable_indexes_set_tbl_idx","called\n"));

    /* cabinetEnvironDeviceNumber(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
    tbl_idx->cabinetEnvironDeviceNumber = cabinetEnvironDeviceNumber_val;
    
    /* cabinetEnvironDeviceIndex(3)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
    tbl_idx->cabinetEnvironDeviceIndex = cabinetEnvironDeviceIndex_val;
    

    return MFD_SUCCESS;
} /* cabinetEnvironDevicesTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
cabinetEnvironDevicesTable_indexes_set(cabinetEnvironDevicesTable_rowreq_ctx *rowreq_ctx, long cabinetEnvironDeviceNumber_val, long cabinetEnvironDeviceIndex_val)
{
    DEBUGMSGTL(("verbose:cabinetEnvironDevicesTable:cabinetEnvironDevicesTable_indexes_set","called\n"));

    if(MFD_SUCCESS != cabinetEnvironDevicesTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , cabinetEnvironDeviceNumber_val
                                   , cabinetEnvironDeviceIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != cabinetEnvironDevicesTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* cabinetEnvironDevicesTable_indexes_set */


/*---------------------------------------------------------------------
 * NTCIP1202-v03::cabinetEnvironDeviceEntry.cabinetEnvironDeviceType
 * cabinetEnvironDeviceType is subid 2 of cabinetEnvironDeviceEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.12.2.1.2
 * Description:
<Definition> The type of environment monitoring device to
monitor the cabinet is an enumerated integer.
other: the type of environmental monitoring device is not defined
by this standard.
door: this cabinet environmental monitoring device is a door to
the cabinet.
fan: this cabinet environmental monitoring device is a fan within
the cabinet.
heater: this cabinet environmental monitoring device is a heater
within the cabinet.
floatSwitch: this cabinet environmental monitoring device is a
float switch for water level detection.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.12.2.1.2
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 5. Values:  other(1), door(2), fan(3), heater(4), floatSwitch(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the cabinetEnvironDeviceType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param cabinetEnvironDeviceType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
cabinetEnvironDeviceType_get( cabinetEnvironDevicesTable_rowreq_ctx *rowreq_ctx, u_long * cabinetEnvironDeviceType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != cabinetEnvironDeviceType_val_ptr );


    DEBUGMSGTL(("verbose:cabinetEnvironDevicesTable:cabinetEnvironDeviceType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the cabinetEnvironDeviceType data.
 * copy (* cabinetEnvironDeviceType_val_ptr ) from rowreq_ctx->data
 */
    (* cabinetEnvironDeviceType_val_ptr ) = rowreq_ctx->data.cabinetEnvironDeviceType;

    return MFD_SUCCESS;
} /* cabinetEnvironDeviceType_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::cabinetEnvironDeviceEntry.cabinetEnvironDeviceDescription
 * cabinetEnvironDeviceDescription is subid 4 of cabinetEnvironDeviceEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.1206.4.2.1.12.2.1.4
 * Description:
<Definition> Human-readable description of the cabinet
environmental device. This value should provide enough
information for maintenance personnel to identify the type (door,
fan, heater, etc.) and physical location of the device defined in
this row within the CU or CU cabinet.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.12.2.1.4
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 64;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 64)
 */
/**
 * Extract the current value of the cabinetEnvironDeviceDescription data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param cabinetEnvironDeviceDescription_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param cabinetEnvironDeviceDescription_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by cabinetEnvironDeviceDescription.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*cabinetEnvironDeviceDescription_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update cabinetEnvironDeviceDescription_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
cabinetEnvironDeviceDescription_get( cabinetEnvironDevicesTable_rowreq_ctx *rowreq_ctx, char **cabinetEnvironDeviceDescription_val_ptr_ptr, size_t *cabinetEnvironDeviceDescription_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != cabinetEnvironDeviceDescription_val_ptr_ptr) && (NULL != *cabinetEnvironDeviceDescription_val_ptr_ptr));
   netsnmp_assert( NULL != cabinetEnvironDeviceDescription_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:cabinetEnvironDevicesTable:cabinetEnvironDeviceDescription_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the cabinetEnvironDeviceDescription data.
 * copy (* cabinetEnvironDeviceDescription_val_ptr_ptr ) data and (* cabinetEnvironDeviceDescription_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for cabinetEnvironDeviceDescription data
     */
    if ((NULL == (* cabinetEnvironDeviceDescription_val_ptr_ptr )) ||
        ((* cabinetEnvironDeviceDescription_val_ptr_len_ptr ) <
         (rowreq_ctx->data.cabinetEnvironDeviceDescription_len* sizeof(rowreq_ctx->data.cabinetEnvironDeviceDescription[0])))) {
        /*
         * allocate space for cabinetEnvironDeviceDescription data
         */
        (* cabinetEnvironDeviceDescription_val_ptr_ptr ) = malloc(rowreq_ctx->data.cabinetEnvironDeviceDescription_len* sizeof(rowreq_ctx->data.cabinetEnvironDeviceDescription[0]));
        if(NULL == (* cabinetEnvironDeviceDescription_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.cabinetEnvironDeviceDescription)\n");
            return MFD_ERROR;
        }
    }
    (* cabinetEnvironDeviceDescription_val_ptr_len_ptr ) = rowreq_ctx->data.cabinetEnvironDeviceDescription_len* sizeof(rowreq_ctx->data.cabinetEnvironDeviceDescription[0]);
    memcpy( (* cabinetEnvironDeviceDescription_val_ptr_ptr ), rowreq_ctx->data.cabinetEnvironDeviceDescription, rowreq_ctx->data.cabinetEnvironDeviceDescription_len* sizeof(rowreq_ctx->data.cabinetEnvironDeviceDescription[0]) );

    return MFD_SUCCESS;
} /* cabinetEnvironDeviceDescription_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::cabinetEnvironDeviceEntry.cabinetEnvironDeviceOnStatus
 * cabinetEnvironDeviceOnStatus is subid 5 of cabinetEnvironDeviceEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.1206.4.2.1.12.2.1.5
 * Description:
<Definition> Indicates if this environmental monitoring
device is on/open or off/closed. A bit orientation of 1 (true)
indicates the environmental monitoring device is on, or in the
case of a door, the door is open. A value of 0 (false) indicates
this environmental monitoring device is off, or in the case of a
door, the door is closed.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.12.2.1.5
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 2. Values:  true(1), false(2)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the cabinetEnvironDeviceOnStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param cabinetEnvironDeviceOnStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
cabinetEnvironDeviceOnStatus_get( cabinetEnvironDevicesTable_rowreq_ctx *rowreq_ctx, u_long * cabinetEnvironDeviceOnStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != cabinetEnvironDeviceOnStatus_val_ptr );


    DEBUGMSGTL(("verbose:cabinetEnvironDevicesTable:cabinetEnvironDeviceOnStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the cabinetEnvironDeviceOnStatus data.
 * copy (* cabinetEnvironDeviceOnStatus_val_ptr ) from rowreq_ctx->data
 */
    (* cabinetEnvironDeviceOnStatus_val_ptr ) = rowreq_ctx->data.cabinetEnvironDeviceOnStatus;

    return MFD_SUCCESS;
} /* cabinetEnvironDeviceOnStatus_get */

/*---------------------------------------------------------------------
 * NTCIP1202-v03::cabinetEnvironDeviceEntry.cabinetEnvironDeviceErrorStatus
 * cabinetEnvironDeviceErrorStatus is subid 6 of cabinetEnvironDeviceEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.1206.4.2.1.12.2.1.6
 * Description:
<Definition> Indicates the current status of the
environmental monitoring device.
<Object Identifier> 1.3.6.1.4.1.1206.4.2.1.12.2.1.6
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 4. Values:  other(1), noError(2), fail(3), notMonitored(4)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the cabinetEnvironDeviceErrorStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param cabinetEnvironDeviceErrorStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
cabinetEnvironDeviceErrorStatus_get( cabinetEnvironDevicesTable_rowreq_ctx *rowreq_ctx, u_long * cabinetEnvironDeviceErrorStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != cabinetEnvironDeviceErrorStatus_val_ptr );


    DEBUGMSGTL(("verbose:cabinetEnvironDevicesTable:cabinetEnvironDeviceErrorStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the cabinetEnvironDeviceErrorStatus data.
 * copy (* cabinetEnvironDeviceErrorStatus_val_ptr ) from rowreq_ctx->data
 */
    (* cabinetEnvironDeviceErrorStatus_val_ptr ) = rowreq_ctx->data.cabinetEnvironDeviceErrorStatus;

    return MFD_SUCCESS;
} /* cabinetEnvironDeviceErrorStatus_get */



/** @} */
