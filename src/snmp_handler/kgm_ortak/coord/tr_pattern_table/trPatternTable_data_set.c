/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-set.m2c
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "defs_cpu.h"
#include "utils.h"

/* include our parent header */
#include "coord_data.h"



/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 * 
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table trPatternTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * kgm-ortak::trPatternTable is subid 2 of coord.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2, length: 12
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * trPatternTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * trPatternTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
trPatternTable_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup trPatternTable undo.
     * set up trPatternTable undo information, in preparation for a set.
     * Undo storage is in (* patternOutputSupervision_val_ptr )*
     */

    return rc;
} /* trPatternTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
trPatternTable_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> trPatternTable undo.
     * trPatternTable undo information, in response to a failed set.
     * Undo storage is in (* patternOutputSupervision_val_ptr )*
     */

    return rc;
} /* trPatternTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
trPatternTable_undo_cleanup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup trPatternTable undo.
     * Undo storage is in (* patternOutputSupervision_val_ptr )*
     */

    return rc;
} /* trPatternTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * trPatternTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param trPatternTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
trPatternTable_commit( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int save_flags;
    int row = rowreq_ctx->tbl_idx.patternIndex - 1;	
    struct tm ts;	
    time_t now;	
    int i = 0;	
    if(row > 3)	
        row = 3;

    message_t* msg_ptr = &snmp_message_buf;
    memset(msg_ptr, 0, sizeof(message_t));
    msg_ptr->cmd_buffer[0] = ASIST_CMD_SET_COORDINATE_PARAM;
    msg_ptr->cmd_size      = sizeof(struct coord_param_s) + 1;
    struct coord_param_s *coord_param_ptr = (struct coord_param_s *)&msg_ptr->cmd_buffer[1];
    coord_param_ptr->cp_subjunc_no = row + 1;

    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit trPatternTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_PATTERNENABLED_FLAG) {
       save_flags &= ~COLUMN_PATTERNENABLED_FLAG; /* clear patternEnabled */
       /*
        * TODO:482:o: |-> commit column patternEnabled.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternEnabled commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternEnabled
             */
            coord_param_ptr->cp_active = rowreq_ctx->data.patternEnabled;

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNENABLED_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNEXECMODE_FLAG) {
       save_flags &= ~COLUMN_PATTERNEXECMODE_FLAG; /* clear patternExecMode */
       /*
        * TODO:482:o: |-> commit column patternExecMode.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternExecMode commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternExecMode
             */
            switch (rowreq_ctx->data.patternExecMode)
            {
            case 10: // Program Error
                coord_param_ptr->cp_mode = 11;
                break;

            case 11: // testSignalPlan
                coord_param_ptr->cp_mode = 10;
                break;
            
            default:
                coord_param_ptr->cp_mode = rowreq_ctx->data.patternExecMode;
                break;
            }

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNEXECMODE_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNSTRUCT_FLAG) {
       save_flags &= ~COLUMN_PATTERNSTRUCT_FLAG; /* clear patternStruct */
       /*
        * TODO:482:o: |-> commit column patternStruct.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternStruct commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternStruct
             */
            coord_param_ptr->cp_structure = rowreq_ctx->data.patternStruct;

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNSTRUCT_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNPLANNUMBER_FLAG) {
       save_flags &= ~COLUMN_PATTERNPLANNUMBER_FLAG; /* clear patternPlanNumber */
       /*
        * TODO:482:o: |-> commit column patternPlanNumber.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternPlanNumber commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternPlanNumber
             */
            coord_param_ptr->cp_plan = rowreq_ctx->data.patternPlanNumber;

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNPLANNUMBER_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNSYNC_FLAG) {
       save_flags &= ~COLUMN_PATTERNSYNC_FLAG; /* clear patternSync */
       /*
        * TODO:482:o: |-> commit column patternSync.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternSync commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternSync
             */
            switch (rowreq_ctx->data.patternSync)
            {
            case 0: // Yeşil dalga uygulanmayacaktır.
                coord_param_ptr->cp_sync = 1;
                break;

            case 1: // Yeşil dalga uygulanacaktır.
                coord_param_ptr->cp_sync = 2;
                break;
            
            default:
                coord_param_ptr->cp_sync = 0;
                break;
            }

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNSYNC_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNOFFSETTIME_FLAG) {
       save_flags &= ~COLUMN_PATTERNOFFSETTIME_FLAG; /* clear patternOffsetTime */
       /*
        * TODO:482:o: |-> commit column patternOffsetTime.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternOffsetTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternOffsetTime
             */
            if(rowreq_ctx->data.patternOffsetTime == 65535) // No Change
                coord_param_ptr->cp_distance = 0;
            else
                coord_param_ptr->cp_distance = rowreq_ctx->data.patternOffsetTime;

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNOFFSETTIME_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNSTAGECOUNT_FLAG) {
       save_flags &= ~COLUMN_PATTERNSTAGECOUNT_FLAG; /* clear patternStageCount */
       /*
        * TODO:482:o: |-> commit column patternStageCount.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternStageCount commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternStageCount
             */

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNSTAGECOUNT_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNSTARTDATE_FLAG) {
       save_flags &= ~COLUMN_PATTERNSTARTDATE_FLAG; /* clear patternStartDate */
       /*
        * TODO:482:o: |-> commit column patternStartDate.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternStartDate commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternStartDate
             */
            now = (time_t)rowreq_ctx->data.patternStartDate;	
            ts = *localtime(&now);	
            coord_param_ptr->cp_start_time.year     = ts.tm_year + (1900 - 2000);
            coord_param_ptr->cp_start_time.month    = ts.tm_mon + 1;
            coord_param_ptr->cp_start_time.day      = ts.tm_mday;
            coord_param_ptr->cp_start_time.hour     = ts.tm_hour;
            coord_param_ptr->cp_start_time.min      = ts.tm_min;
            coord_param_ptr->cp_start_time.sec      = ts.tm_sec;

            rowreq_ctx->column_set_flags |= COLUMN_PATTERNSTARTDATE_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNENDDATE_FLAG) {
       save_flags &= ~COLUMN_PATTERNENDDATE_FLAG; /* clear patternEndDate */
       /*
        * TODO:482:o: |-> commit column patternEndDate.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternEndDate commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternEndDate
             */
            now = (time_t)rowreq_ctx->data.patternEndDate;	
            ts = *localtime(&now);	
            coord_param_ptr->cp_end_time.year     = ts.tm_year + (1900 - 2000);
            coord_param_ptr->cp_end_time.month    = ts.tm_mon + 1;
            coord_param_ptr->cp_end_time.day      = ts.tm_mday;
            coord_param_ptr->cp_end_time.hour     = ts.tm_hour;
            coord_param_ptr->cp_end_time.min      = ts.tm_min;
            coord_param_ptr->cp_end_time.sec      = ts.tm_sec;
            
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNENDDATE_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNGREENWAVECYCLETIME_FLAG) {
       save_flags &= ~COLUMN_PATTERNGREENWAVECYCLETIME_FLAG; /* clear patternGreenwaveCycleTime */
       /*
        * TODO:482:o: |-> commit column patternGreenwaveCycleTime.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternGreenwaveCycleTime commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternGreenwaveCycleTime
             */
            coord_param_ptr->cp_distance = rowreq_ctx->data.patternGreenwaveCycleTime;
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNGREENWAVECYCLETIME_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNGREENWAVESTAGEID_FLAG) {
       save_flags &= ~COLUMN_PATTERNGREENWAVESTAGEID_FLAG; /* clear patternGreenwaveStageId */
       /*
        * TODO:482:o: |-> commit column patternGreenwaveStageId.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternGreenwaveStageId commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternGreenwaveStageId
             */
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNGREENWAVESTAGEID_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNGREENWAVERETURNSTAGEID_FLAG) {
       save_flags &= ~COLUMN_PATTERNGREENWAVERETURNSTAGEID_FLAG; /* clear patternGreenWaveReturnStageId */
       /*
        * TODO:482:o: |-> commit column patternGreenWaveReturnStageId.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternGreenWaveReturnStageId commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternGreenWaveReturnStageId
             */
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNGREENWAVERETURNSTAGEID_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNSENSORENABLE_FLAG) {
       save_flags &= ~COLUMN_PATTERNSENSORENABLE_FLAG; /* clear patternSensorEnable */
       /*
        * TODO:482:o: |-> commit column patternSensorEnable.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternSensorEnable commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternSensorEnable
             */
            coord_param_ptr->cp_sensor_enable = rowreq_ctx->data.patternSensorEnable;
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNSENSORENABLE_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNSENSORSUPERVISION_FLAG) {
       save_flags &= ~COLUMN_PATTERNSENSORSUPERVISION_FLAG; /* clear patternSensorSupervision */
       /*
        * TODO:482:o: |-> commit column patternSensorSupervision.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternSensorSupervision commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternSensorSupervision
             */
            coord_param_ptr->cp_sensor_supervision_enable = rowreq_ctx->data.patternSensorSupervision;
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNSENSORSUPERVISION_FLAG;
       }
    }

    if (save_flags & COLUMN_PATTERNOUTPUTSUPERVISION_FLAG) {
       save_flags &= ~COLUMN_PATTERNOUTPUTSUPERVISION_FLAG; /* clear patternOutputSupervision */
       /*
        * TODO:482:o: |-> commit column patternOutputSupervision.
        */
       rc = 0;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"trPatternTable column patternOutputSupervision commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo patternOutputSupervision
             */
            coord_param_ptr->cp_output_supervision_enable = rowreq_ctx->data.patternOutputSupervision;
            rowreq_ctx->column_set_flags |= COLUMN_PATTERNOUTPUTSUPERVISION_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
        send_read_message(msg_ptr);
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* trPatternTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * trPatternTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param trPatternTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
trPatternTable_undo_commit( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo trPatternTable commit.
     * check each column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNENABLED_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNEXECMODE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNSTRUCT_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNPLANNUMBER_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNSYNC_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNOFFSETTIME_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNSTAGECOUNT_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNSTARTDATE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNENDDATE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNGREENWAVECYCLETIME_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNGREENWAVESTAGEID_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNGREENWAVERETURNSTAGEID_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNSENSORENABLE_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNSENSORSUPERVISION_FLAG) {}
     * eg: if (rowreq_ctx->column_set_flags & COLUMN_PATTERNOUTPUTSUPERVISION_FLAG) {}
     */

    
    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* trPatternTable_undo_commit */

/*
 * TODO:440:M: Implement trPatternTable node value checks.
 * TODO:450:M: Implement trPatternTable undo functions.
 * TODO:460:M: Implement trPatternTable set functions.
 * TODO:480:M: Implement trPatternTable commit functions.
 */
/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternEnabled
 * patternEnabled is subid 3 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.3
 * Description:
<Definition>
		İlgili değişikliğin uygulanıp uygulanmayacağı
		0: İlgili pattern uygulanmayacak.
		1: İlgili pattern uygulanacak.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 1;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternEnabled_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 1
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternEnabled_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternEnabled_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternEnabled_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternEnabled value.
     */

    return MFD_SUCCESS; /* patternEnabled value not illegal */
} /* patternEnabled_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternEnabled_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternEnabled_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternEnabled undo.
     */
    /*
     * copy patternEnabled data
     * set rowreq_ctx->undo->patternEnabled from rowreq_ctx->data.patternEnabled
     */
    rowreq_ctx->undo->patternEnabled = rowreq_ctx->data.patternEnabled;


    return MFD_SUCCESS;
} /* patternEnabled_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternEnabled_val
 *        A long containing the new value.
 */
int
patternEnabled_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternEnabled_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternEnabled_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternEnabled value.
     * set patternEnabled value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternEnabled = patternEnabled_val;

    return MFD_SUCCESS;
} /* patternEnabled_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternEnabled_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternEnabled_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternEnabled undo.
     */
    /*
     * copy patternEnabled data
     * set rowreq_ctx->data.patternEnabled from rowreq_ctx->undo->patternEnabled
     */
    rowreq_ctx->data.patternEnabled = rowreq_ctx->undo->patternEnabled;

    
    return MFD_SUCCESS;
} /* patternEnabled_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternExecMode
 * patternExecMode is subid 4 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.4
 * Description:
<Definition>
Hangi modda olduğu bilgisini içerir.
Program(3): Cihaz haftalık plandaki düzene göre çalışıyor.
		Flash(4): Cihaz flaş moduna zorlanmış
		FailFlash(5): Cihaz arızi bir durumdan dolayı flaş
moduna geçmiş
		AllYellow(6): Tüm çıkışlar sarı
		AllRed(7): Tüm çıkışlar kırmızı
AllDark(8): Tüm çıkışlar sönük
TestOutputs(9): Çıkışların lambalara doğru bir şekilde bağlanıp bağlanmadığını kontrol etmek için sıra ile her bir çıkışa yeşil, sarı, kırmızı, kırmızı sarı renklerinin verilmesidir.
TestSignalPlan(11): Bu modda sinyal çıkışları kapalıdır. Diğer her şey program modunda çalışmaktadır.
FixedTime(12): Sabit süreli mod.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 9. Values:  program(3), flash(4), failFlash(5), allYellow(6), allRed(7), allDark(8), testOutputs(9), testSignalPlan(11), fixedTime(12)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternExecMode_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  program(3), flash(4), failFlash(5), allYellow(6), allRed(7), allDark(8), testOutputs(9), testSignalPlan(11), fixedTime(12)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternExecMode_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, u_long patternExecMode_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternExecMode_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternExecMode value.
     */

    return MFD_SUCCESS; /* patternExecMode value not illegal */
} /* patternExecMode_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternExecMode_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternExecMode_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternExecMode undo.
     */
    /*
     * copy patternExecMode data
     * set rowreq_ctx->undo->patternExecMode from rowreq_ctx->data.patternExecMode
     */
    rowreq_ctx->undo->patternExecMode = rowreq_ctx->data.patternExecMode;


    return MFD_SUCCESS;
} /* patternExecMode_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternExecMode_val
 *        A long containing the new value.
 */
int
patternExecMode_set( trPatternTable_rowreq_ctx *rowreq_ctx, u_long patternExecMode_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternExecMode_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternExecMode value.
     * set patternExecMode value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternExecMode = patternExecMode_val;

    return MFD_SUCCESS;
} /* patternExecMode_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternExecMode_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternExecMode_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternExecMode undo.
     */
    /*
     * copy patternExecMode data
     * set rowreq_ctx->data.patternExecMode from rowreq_ctx->undo->patternExecMode
     */
    rowreq_ctx->data.patternExecMode = rowreq_ctx->undo->patternExecMode;

    
    return MFD_SUCCESS;
} /* patternExecMode_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStruct
 * patternStruct is subid 7 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.7
 * Description:
<Definition>
		Geçilmesi istenilen yapı
		255 değeri yapı değişikliği istenmediği anlamına
gelir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStruct_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternStruct_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternStruct_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternStruct_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternStruct value.
     */

    return MFD_SUCCESS; /* patternStruct value not illegal */
} /* patternStruct_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternStruct_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternStruct_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternStruct undo.
     */
    /*
     * copy patternStruct data
     * set rowreq_ctx->undo->patternStruct from rowreq_ctx->data.patternStruct
     */
    rowreq_ctx->undo->patternStruct = rowreq_ctx->data.patternStruct;


    return MFD_SUCCESS;
} /* patternStruct_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternStruct_val
 *        A long containing the new value.
 */
int
patternStruct_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternStruct_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternStruct_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternStruct value.
     * set patternStruct value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternStruct = patternStruct_val;

    return MFD_SUCCESS;
} /* patternStruct_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternStruct_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternStruct_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternStruct undo.
     */
    /*
     * copy patternStruct data
     * set rowreq_ctx->data.patternStruct from rowreq_ctx->undo->patternStruct
     */
    rowreq_ctx->data.patternStruct = rowreq_ctx->undo->patternStruct;

    
    return MFD_SUCCESS;
} /* patternStruct_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternPlanNumber
 * patternPlanNumber is subid 8 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.8
 * Description:
<Definition>
Geçilmesi istenilen plan
		255 değeri plan değişikliği istenmediği anlamına
		gelir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternPlanNumber_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternPlanNumber_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternPlanNumber_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternPlanNumber_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternPlanNumber value.
     */

    return MFD_SUCCESS; /* patternPlanNumber value not illegal */
} /* patternPlanNumber_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternPlanNumber_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternPlanNumber_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternPlanNumber undo.
     */
    /*
     * copy patternPlanNumber data
     * set rowreq_ctx->undo->patternPlanNumber from rowreq_ctx->data.patternPlanNumber
     */
    rowreq_ctx->undo->patternPlanNumber = rowreq_ctx->data.patternPlanNumber;


    return MFD_SUCCESS;
} /* patternPlanNumber_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternPlanNumber_val
 *        A long containing the new value.
 */
int
patternPlanNumber_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternPlanNumber_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternPlanNumber_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternPlanNumber value.
     * set patternPlanNumber value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternPlanNumber = patternPlanNumber_val;

    return MFD_SUCCESS;
} /* patternPlanNumber_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternPlanNumber_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternPlanNumber_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternPlanNumber undo.
     */
    /*
     * copy patternPlanNumber data
     * set rowreq_ctx->data.patternPlanNumber from rowreq_ctx->undo->patternPlanNumber
     */
    rowreq_ctx->data.patternPlanNumber = rowreq_ctx->undo->patternPlanNumber;

    
    return MFD_SUCCESS;
} /* patternPlanNumber_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternSync
 * patternSync is subid 9 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.9
 * Description:
<Definition>
		0: Yeşil dalga uygulanmayacaktır.
		1: Yeşil dalga uygulanacaktır.
		2: Yeşil dalga ile ilgili bir değişiklik olmayacak.
Mevcut duruma devam edilecektir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 2;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternSync_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 2
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternSync_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternSync_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternSync_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternSync value.
     */

    return MFD_SUCCESS; /* patternSync value not illegal */
} /* patternSync_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternSync_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternSync_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternSync undo.
     */
    /*
     * copy patternSync data
     * set rowreq_ctx->undo->patternSync from rowreq_ctx->data.patternSync
     */
    rowreq_ctx->undo->patternSync = rowreq_ctx->data.patternSync;


    return MFD_SUCCESS;
} /* patternSync_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternSync_val
 *        A long containing the new value.
 */
int
patternSync_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternSync_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternSync_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternSync value.
     * set patternSync value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternSync = patternSync_val;

    return MFD_SUCCESS;
} /* patternSync_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternSync_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternSync_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternSync undo.
     */
    /*
     * copy patternSync data
     * set rowreq_ctx->data.patternSync from rowreq_ctx->undo->patternSync
     */
    rowreq_ctx->data.patternSync = rowreq_ctx->undo->patternSync;

    
    return MFD_SUCCESS;
} /* patternSync_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternOffsetTime
 * patternOffsetTime is subid 10 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.10
 * Description:
<Definition>
		Yeşil dalga ofseti(tenth cinsinden)
		65535 ise değişiklik istenmiyor. Yeşil dalga ofseti bağıl bir değerdir. Referans devre başlangıç anlarına göre ölçülür. Referans başlangıç zamanı cihazların yeşil dalga algoritmalarına göre değişebilir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternOffsetTime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternOffsetTime_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternOffsetTime_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternOffsetTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternOffsetTime value.
     */

    return MFD_SUCCESS; /* patternOffsetTime value not illegal */
} /* patternOffsetTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternOffsetTime_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternOffsetTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternOffsetTime undo.
     */
    /*
     * copy patternOffsetTime data
     * set rowreq_ctx->undo->patternOffsetTime from rowreq_ctx->data.patternOffsetTime
     */
    rowreq_ctx->undo->patternOffsetTime = rowreq_ctx->data.patternOffsetTime;


    return MFD_SUCCESS;
} /* patternOffsetTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternOffsetTime_val
 *        A long containing the new value.
 */
int
patternOffsetTime_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternOffsetTime_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternOffsetTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternOffsetTime value.
     * set patternOffsetTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternOffsetTime = patternOffsetTime_val;

    return MFD_SUCCESS;
} /* patternOffsetTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternOffsetTime_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternOffsetTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternOffsetTime undo.
     */
    /*
     * copy patternOffsetTime data
     * set rowreq_ctx->data.patternOffsetTime from rowreq_ctx->undo->patternOffsetTime
     */
    rowreq_ctx->data.patternOffsetTime = rowreq_ctx->undo->patternOffsetTime;

    
    return MFD_SUCCESS;
} /* patternOffsetTime_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStageCount
 * patternStageCount is subid 11 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.11
 * Description:
<Definition>
		Sinyal planındaki faz sayısı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStageCount_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternStageCount_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternStageCount_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternStageCount_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternStageCount value.
     */

    return MFD_SUCCESS; /* patternStageCount value not illegal */
} /* patternStageCount_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternStageCount_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternStageCount_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternStageCount undo.
     */
    /*
     * copy patternStageCount data
     * set rowreq_ctx->undo->patternStageCount from rowreq_ctx->data.patternStageCount
     */
    rowreq_ctx->undo->patternStageCount = rowreq_ctx->data.patternStageCount;


    return MFD_SUCCESS;
} /* patternStageCount_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternStageCount_val
 *        A long containing the new value.
 */
int
patternStageCount_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternStageCount_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternStageCount_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternStageCount value.
     * set patternStageCount value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternStageCount = patternStageCount_val;

    return MFD_SUCCESS;
} /* patternStageCount_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternStageCount_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternStageCount_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternStageCount undo.
     */
    /*
     * copy patternStageCount data
     * set rowreq_ctx->data.patternStageCount from rowreq_ctx->undo->patternStageCount
     */
    rowreq_ctx->data.patternStageCount = rowreq_ctx->undo->patternStageCount;

    
    return MFD_SUCCESS;
} /* patternStageCount_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStartDate
 * patternStartDate is subid 14 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.14
 * Description:
<Definition>
		Plan değişkliğinin devreye gireceği zaman. 01.01.1970 00:00 (epoch) tarihinden itibaren geçen saniye sayısı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStartDate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternStartDate_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, u_long patternStartDate_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternStartDate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternStartDate value.
     */

    return MFD_SUCCESS; /* patternStartDate value not illegal */
} /* patternStartDate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternStartDate_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternStartDate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternStartDate undo.
     */
    /*
     * copy patternStartDate data
     * set rowreq_ctx->undo->patternStartDate from rowreq_ctx->data.patternStartDate
     */
    rowreq_ctx->undo->patternStartDate = rowreq_ctx->data.patternStartDate;


    return MFD_SUCCESS;
} /* patternStartDate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternStartDate_val
 *        A u_long containing the new value.
 */
int
patternStartDate_set( trPatternTable_rowreq_ctx *rowreq_ctx, u_long patternStartDate_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternStartDate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternStartDate value.
     * set patternStartDate value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternStartDate = patternStartDate_val;

    return MFD_SUCCESS;
} /* patternStartDate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternStartDate_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternStartDate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternStartDate undo.
     */
    /*
     * copy patternStartDate data
     * set rowreq_ctx->data.patternStartDate from rowreq_ctx->undo->patternStartDate
     */
    rowreq_ctx->data.patternStartDate = rowreq_ctx->undo->patternStartDate;

    
    return MFD_SUCCESS;
} /* patternStartDate_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternEndDate
 * patternEndDate is subid 15 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.15
 * Description:
<Definition>
		Plan değişikliğinin devre dışı kalacağı zaman. 01.01.1970 00:00 (epoch) tarihinden itibaren geçen saniye sayısı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternEndDate_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_COUNTER
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternEndDate_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, u_long patternEndDate_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternEndDate_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternEndDate value.
     */

    return MFD_SUCCESS; /* patternEndDate value not illegal */
} /* patternEndDate_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternEndDate_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternEndDate_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternEndDate undo.
     */
    /*
     * copy patternEndDate data
     * set rowreq_ctx->undo->patternEndDate from rowreq_ctx->data.patternEndDate
     */
    rowreq_ctx->undo->patternEndDate = rowreq_ctx->data.patternEndDate;


    return MFD_SUCCESS;
} /* patternEndDate_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternEndDate_val
 *        A u_long containing the new value.
 */
int
patternEndDate_set( trPatternTable_rowreq_ctx *rowreq_ctx, u_long patternEndDate_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternEndDate_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternEndDate value.
     * set patternEndDate value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternEndDate = patternEndDate_val;

    return MFD_SUCCESS;
} /* patternEndDate_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternEndDate_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternEndDate_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternEndDate undo.
     */
    /*
     * copy patternEndDate data
     * set rowreq_ctx->data.patternEndDate from rowreq_ctx->undo->patternEndDate
     */
    rowreq_ctx->data.patternEndDate = rowreq_ctx->undo->patternEndDate;

    
    return MFD_SUCCESS;
} /* patternEndDate_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternGreenwaveCycleTime
 * patternGreenwaveCycleTime is subid 16 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.16
 * Description:
<Definition>

		Yeşil dalga devre süresi(tenth cinsinden)
		65535 ise değiştirilmez.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternGreenwaveCycleTime_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 65535
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternGreenwaveCycleTime_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternGreenwaveCycleTime_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveCycleTime_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternGreenwaveCycleTime value.
     */

    return MFD_SUCCESS; /* patternGreenwaveCycleTime value not illegal */
} /* patternGreenwaveCycleTime_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternGreenwaveCycleTime_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveCycleTime_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternGreenwaveCycleTime undo.
     */
    /*
     * copy patternGreenwaveCycleTime data
     * set rowreq_ctx->undo->patternGreenwaveCycleTime from rowreq_ctx->data.patternGreenwaveCycleTime
     */
    rowreq_ctx->undo->patternGreenwaveCycleTime = rowreq_ctx->data.patternGreenwaveCycleTime;


    return MFD_SUCCESS;
} /* patternGreenwaveCycleTime_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternGreenwaveCycleTime_val
 *        A long containing the new value.
 */
int
patternGreenwaveCycleTime_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternGreenwaveCycleTime_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveCycleTime_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternGreenwaveCycleTime value.
     * set patternGreenwaveCycleTime value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternGreenwaveCycleTime = patternGreenwaveCycleTime_val;

    return MFD_SUCCESS;
} /* patternGreenwaveCycleTime_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternGreenwaveCycleTime_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveCycleTime_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternGreenwaveCycleTime undo.
     */
    /*
     * copy patternGreenwaveCycleTime data
     * set rowreq_ctx->data.patternGreenwaveCycleTime from rowreq_ctx->undo->patternGreenwaveCycleTime
     */
    rowreq_ctx->data.patternGreenwaveCycleTime = rowreq_ctx->undo->patternGreenwaveCycleTime;

    
    return MFD_SUCCESS;
} /* patternGreenwaveCycleTime_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternGreenwaveStageId
 * patternGreenwaveStageId is subid 17 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.17
 * Description:
<Definition>
Yeşil dalga faz numarası. Yeşil dalga uygulaması belirtilen faz referans alınarak yapılır.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternGreenwaveStageId_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternGreenwaveStageId_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternGreenwaveStageId_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveStageId_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternGreenwaveStageId value.
     */

    return MFD_SUCCESS; /* patternGreenwaveStageId value not illegal */
} /* patternGreenwaveStageId_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternGreenwaveStageId_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveStageId_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternGreenwaveStageId undo.
     */
    /*
     * copy patternGreenwaveStageId data
     * set rowreq_ctx->undo->patternGreenwaveStageId from rowreq_ctx->data.patternGreenwaveStageId
     */
    rowreq_ctx->undo->patternGreenwaveStageId = rowreq_ctx->data.patternGreenwaveStageId;


    return MFD_SUCCESS;
} /* patternGreenwaveStageId_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternGreenwaveStageId_val
 *        A long containing the new value.
 */
int
patternGreenwaveStageId_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternGreenwaveStageId_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveStageId_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternGreenwaveStageId value.
     * set patternGreenwaveStageId value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternGreenwaveStageId = patternGreenwaveStageId_val;

    return MFD_SUCCESS;
} /* patternGreenwaveStageId_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternGreenwaveStageId_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveStageId_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternGreenwaveStageId undo.
     */
    /*
     * copy patternGreenwaveStageId data
     * set rowreq_ctx->data.patternGreenwaveStageId from rowreq_ctx->undo->patternGreenwaveStageId
     */
    rowreq_ctx->data.patternGreenwaveStageId = rowreq_ctx->undo->patternGreenwaveStageId;

    
    return MFD_SUCCESS;
} /* patternGreenwaveStageId_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternGreenWaveReturnStageId
 * patternGreenWaveReturnStageId is subid 18 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.18
 * Description:
<Definition>
return phase
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternGreenWaveReturnStageId_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternGreenWaveReturnStageId_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternGreenWaveReturnStageId_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternGreenWaveReturnStageId_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternGreenWaveReturnStageId value.
     */

    return MFD_SUCCESS; /* patternGreenWaveReturnStageId value not illegal */
} /* patternGreenWaveReturnStageId_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternGreenWaveReturnStageId_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternGreenWaveReturnStageId_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternGreenWaveReturnStageId undo.
     */
    /*
     * copy patternGreenWaveReturnStageId data
     * set rowreq_ctx->undo->patternGreenWaveReturnStageId from rowreq_ctx->data.patternGreenWaveReturnStageId
     */
    rowreq_ctx->undo->patternGreenWaveReturnStageId = rowreq_ctx->data.patternGreenWaveReturnStageId;


    return MFD_SUCCESS;
} /* patternGreenWaveReturnStageId_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternGreenWaveReturnStageId_val
 *        A long containing the new value.
 */
int
patternGreenWaveReturnStageId_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternGreenWaveReturnStageId_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternGreenWaveReturnStageId_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternGreenWaveReturnStageId value.
     * set patternGreenWaveReturnStageId value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternGreenWaveReturnStageId = patternGreenWaveReturnStageId_val;

    return MFD_SUCCESS;
} /* patternGreenWaveReturnStageId_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternGreenWaveReturnStageId_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternGreenWaveReturnStageId_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternGreenWaveReturnStageId undo.
     */
    /*
     * copy patternGreenWaveReturnStageId data
     * set rowreq_ctx->data.patternGreenWaveReturnStageId from rowreq_ctx->undo->patternGreenWaveReturnStageId
     */
    rowreq_ctx->data.patternGreenWaveReturnStageId = rowreq_ctx->undo->patternGreenWaveReturnStageId;

    
    return MFD_SUCCESS;
} /* patternGreenWaveReturnStageId_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternSensorEnable
 * patternSensorEnable is subid 19 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.19
 * Description:
<Definition>
		Sensörleri devreye almak veya devre dışı bırakmak
için kullanılır.
0: Devre dışı
1: Devrede
2: Değişiklik yok.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 2;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternSensorEnable_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 2
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternSensorEnable_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternSensorEnable_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternSensorEnable_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternSensorEnable value.
     */

    return MFD_SUCCESS; /* patternSensorEnable value not illegal */
} /* patternSensorEnable_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternSensorEnable_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternSensorEnable_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternSensorEnable undo.
     */
    /*
     * copy patternSensorEnable data
     * set rowreq_ctx->undo->patternSensorEnable from rowreq_ctx->data.patternSensorEnable
     */
    rowreq_ctx->undo->patternSensorEnable = rowreq_ctx->data.patternSensorEnable;


    return MFD_SUCCESS;
} /* patternSensorEnable_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternSensorEnable_val
 *        A long containing the new value.
 */
int
patternSensorEnable_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternSensorEnable_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternSensorEnable_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternSensorEnable value.
     * set patternSensorEnable value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternSensorEnable = patternSensorEnable_val;

    return MFD_SUCCESS;
} /* patternSensorEnable_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternSensorEnable_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternSensorEnable_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternSensorEnable undo.
     */
    /*
     * copy patternSensorEnable data
     * set rowreq_ctx->data.patternSensorEnable from rowreq_ctx->undo->patternSensorEnable
     */
    rowreq_ctx->data.patternSensorEnable = rowreq_ctx->undo->patternSensorEnable;

    
    return MFD_SUCCESS;
} /* patternSensorEnable_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternSensorSupervision
 * patternSensorSupervision is subid 20 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.20
 * Description:
<Definition>
Sensör arıza kontrolünü devreye almak veya devre dışı bırakmak
için kullanılır.
0: Devre dışı
1: Devrede
2: Değişiklik yok.

<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternSensorSupervision_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternSensorSupervision_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternSensorSupervision_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternSensorSupervision_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternSensorSupervision value.
     */

    return MFD_SUCCESS; /* patternSensorSupervision value not illegal */
} /* patternSensorSupervision_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternSensorSupervision_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternSensorSupervision_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternSensorSupervision undo.
     */
    /*
     * copy patternSensorSupervision data
     * set rowreq_ctx->undo->patternSensorSupervision from rowreq_ctx->data.patternSensorSupervision
     */
    rowreq_ctx->undo->patternSensorSupervision = rowreq_ctx->data.patternSensorSupervision;


    return MFD_SUCCESS;
} /* patternSensorSupervision_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternSensorSupervision_val
 *        A long containing the new value.
 */
int
patternSensorSupervision_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternSensorSupervision_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternSensorSupervision_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternSensorSupervision value.
     * set patternSensorSupervision value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternSensorSupervision = patternSensorSupervision_val;

    return MFD_SUCCESS;
} /* patternSensorSupervision_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternSensorSupervision_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternSensorSupervision_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternSensorSupervision undo.
     */
    /*
     * copy patternSensorSupervision data
     * set rowreq_ctx->data.patternSensorSupervision from rowreq_ctx->undo->patternSensorSupervision
     */
    rowreq_ctx->data.patternSensorSupervision = rowreq_ctx->undo->patternSensorSupervision;

    
    return MFD_SUCCESS;
} /* patternSensorSupervision_undo */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternOutputSupervision
 * patternOutputSupervision is subid 21 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.21
 * Description:
<Definition>
Sinyal çıkışları arıza kontrolünü devreye almak veya devre dışı bırakmak
için kullanılır.
0: Devre dışı
1: Devrede
2: Değişiklik yok.

<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternOutputSupervision_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *      
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 * 
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * trPatternTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  0 - 255
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
patternOutputSupervision_check_value( trPatternTable_rowreq_ctx *rowreq_ctx, long patternOutputSupervision_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternOutputSupervision_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid patternOutputSupervision value.
     */

    return MFD_SUCCESS; /* patternOutputSupervision value not illegal */
} /* patternOutputSupervision_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (trPatternTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * trPatternTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
patternOutputSupervision_undo_setup( trPatternTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:trPatternTable:patternOutputSupervision_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup patternOutputSupervision undo.
     */
    /*
     * copy patternOutputSupervision data
     * set rowreq_ctx->undo->patternOutputSupervision from rowreq_ctx->data.patternOutputSupervision
     */
    rowreq_ctx->undo->patternOutputSupervision = rowreq_ctx->data.patternOutputSupervision;


    return MFD_SUCCESS;
} /* patternOutputSupervision_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param patternOutputSupervision_val
 *        A long containing the new value.
 */
int
patternOutputSupervision_set( trPatternTable_rowreq_ctx *rowreq_ctx, long patternOutputSupervision_val )
{

    DEBUGMSGTL(("verbose:trPatternTable:patternOutputSupervision_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set patternOutputSupervision value.
     * set patternOutputSupervision value in rowreq_ctx->data
     */
    rowreq_ctx->data.patternOutputSupervision = patternOutputSupervision_val;

    return MFD_SUCCESS;
} /* patternOutputSupervision_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
patternOutputSupervision_undo( trPatternTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:trPatternTable:patternOutputSupervision_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up patternOutputSupervision undo.
     */
    /*
     * copy patternOutputSupervision data
     * set rowreq_ctx->data.patternOutputSupervision from rowreq_ctx->undo->patternOutputSupervision
     */
    rowreq_ctx->data.patternOutputSupervision = rowreq_ctx->undo->patternOutputSupervision;

    
    return MFD_SUCCESS;
} /* patternOutputSupervision_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * trPatternTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-trPatternTable if you don't have dependencies)
 */
int
trPatternTable_check_dependencies(trPatternTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    
    DEBUGMSGTL(("internal:trPatternTable:trPatternTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check trPatternTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    return rc;
} /* trPatternTable_check_dependencies */

/** @} */
