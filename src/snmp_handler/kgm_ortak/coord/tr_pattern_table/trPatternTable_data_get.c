/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-get.m2c
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "trPatternTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement trPatternTable get routines.
 * TODO:240:M: Implement trPatternTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table trPatternTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * kgm-ortak::trPatternTable is subid 2 of coord.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement trPatternTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param subJunctionNumber_val
 * @param patternIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
trPatternTable_indexes_set_tbl_idx(trPatternTable_mib_index *tbl_idx, long subJunctionNumber_val, long patternIndex_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_indexes_set_tbl_idx","called\n"));

    /* subJunctionNumber(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
    tbl_idx->subJunctionNumber = subJunctionNumber_val;
    
    /* patternIndex(2)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
    tbl_idx->patternIndex = patternIndex_val;
    

    return MFD_SUCCESS;
} /* trPatternTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
trPatternTable_indexes_set(trPatternTable_rowreq_ctx *rowreq_ctx, long subJunctionNumber_val, long patternIndex_val)
{
    DEBUGMSGTL(("verbose:trPatternTable:trPatternTable_indexes_set","called\n"));

    if(MFD_SUCCESS != trPatternTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , subJunctionNumber_val
                                   , patternIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != trPatternTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* trPatternTable_indexes_set */


/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternEnabled
 * patternEnabled is subid 3 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.3
 * Description:
<Definition>
		İlgili değişikliğin uygulanıp uygulanmayacağı
		0: İlgili pattern uygulanmayacak.
		1: İlgili pattern uygulanacak.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 1;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternEnabled data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternEnabled_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternEnabled_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternEnabled_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternEnabled_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternEnabled_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternEnabled data.
 * copy (* patternEnabled_val_ptr ) from rowreq_ctx->data
 */
    (* patternEnabled_val_ptr ) = rowreq_ctx->data.patternEnabled;

    return MFD_SUCCESS;
} /* patternEnabled_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternExecMode
 * patternExecMode is subid 4 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.4
 * Description:
<Definition>
Hangi modda olduğu bilgisini içerir.
Program(3): Cihaz haftalık plandaki düzene göre çalışıyor.
		Flash(4): Cihaz flaş moduna zorlanmış
		FailFlash(5): Cihaz arızi bir durumdan dolayı flaş
moduna geçmiş
		AllYellow(6): Tüm çıkışlar sarı
		AllRed(7): Tüm çıkışlar kırmızı
AllDark(8): Tüm çıkışlar sönük
TestOutputs(9): Çıkışların lambalara doğru bir şekilde bağlanıp bağlanmadığını kontrol etmek için sıra ile her bir çıkışa yeşil, sarı, kırmızı, kırmızı sarı renklerinin verilmesidir.
TestSignalPlan(11): Bu modda sinyal çıkışları kapalıdır. Diğer her şey program modunda çalışmaktadır.
FixedTime(12): Sabit süreli mod.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 9. Values:  program(3), flash(4), failFlash(5), allYellow(6), allRed(7), allDark(8), testOutputs(9), testSignalPlan(11), fixedTime(12)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the patternExecMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternExecMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternExecMode_get( trPatternTable_rowreq_ctx *rowreq_ctx, u_long * patternExecMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternExecMode_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternExecMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternExecMode data.
 * copy (* patternExecMode_val_ptr ) from rowreq_ctx->data
 */
    (* patternExecMode_val_ptr ) = 88;//rowreq_ctx->data.patternExecMode;

    return MFD_SUCCESS;
} /* patternExecMode_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternPlanMode
 * patternPlanMode is subid 5 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.5
 * Description:
<Definition>
		FixedPlan(0): Multi Plan(sabit süreli), sensörler devre dışıdır. Faz süreleri haftalık planda belirlenen sürelere göre değişmektedir.
		HalfActuated(1): Kavşağın bazı kollarında sensör bulunmakta(loop dedektör, yaya butonu vb.) bazı kollarında ise sensör bulunmayabilmektedir. Sinyal planındaki bazı fazlar istenirse pas geçilebilmektedir.
		FullyActuated(2): Kavşağın bütün kollarında sensör bulunmaktadır. Sinyal planındaki bütün fazlar açılmakta ve talep olması durumunda max süreye kadar çalıştırılmaktadır.
		CentralAdaptive(3): Bu modda plan süreleri merkezi bir program tarafından üretilmekte ve cihaz tarafından uygulanmaktadır.
		Flashing(4): Flaşlı çalışma(Gece flaşı gibi)
		Dark(5): Çıkışların kapalı olduğu mod(Sadece belli saatlerde işletilen kavşakların olması durumu)
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6. Values:  FixedPlan(0), HalfActuated(1), FullyActuated(2), CentralAdaptive(3), Flashing(4), Dark(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the patternPlanMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternPlanMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternPlanMode_get( trPatternTable_rowreq_ctx *rowreq_ctx, u_long * patternPlanMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternPlanMode_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternPlanMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternPlanMode data.
 * copy (* patternPlanMode_val_ptr ) from rowreq_ctx->data
 */
    (* patternPlanMode_val_ptr ) = 99; // rowreq_ctx->data.patternPlanMode;

    return MFD_SUCCESS;
} /* patternPlanMode_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStage
 * patternStage is subid 6 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.6
 * Description:
<Definition>
Her bir octet bir faz numarasını belirtir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the patternStage data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStage_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param patternStage_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by patternStage.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*patternStage_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update patternStage_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
patternStage_get( trPatternTable_rowreq_ctx *rowreq_ctx, char **patternStage_val_ptr_ptr, size_t *patternStage_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != patternStage_val_ptr_ptr) && (NULL != *patternStage_val_ptr_ptr));
   netsnmp_assert( NULL != patternStage_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternStage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternStage data.
 * copy (* patternStage_val_ptr_ptr ) data and (* patternStage_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for patternStage data
     */
    if ((NULL == (* patternStage_val_ptr_ptr )) ||
        ((* patternStage_val_ptr_len_ptr ) <
         (rowreq_ctx->data.patternStage_len* sizeof(rowreq_ctx->data.patternStage[0])))) {
        /*
         * allocate space for patternStage data
         */
        (* patternStage_val_ptr_ptr ) = malloc(rowreq_ctx->data.patternStage_len* sizeof(rowreq_ctx->data.patternStage[0]));
        if(NULL == (* patternStage_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.patternStage)\n");
            return MFD_ERROR;
        }
    }
    (* patternStage_val_ptr_len_ptr ) = rowreq_ctx->data.patternStage_len* sizeof(rowreq_ctx->data.patternStage[0]);
    memcpy( (* patternStage_val_ptr_ptr ), rowreq_ctx->data.patternStage, rowreq_ctx->data.patternStage_len* sizeof(rowreq_ctx->data.patternStage[0]) );

    return MFD_SUCCESS;
} /* patternStage_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStruct
 * patternStruct is subid 7 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.7
 * Description:
<Definition>
		Geçilmesi istenilen yapı
		255 değeri yapı değişikliği istenmediği anlamına
gelir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternStruct data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStruct_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternStruct_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternStruct_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternStruct_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternStruct_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternStruct data.
 * copy (* patternStruct_val_ptr ) from rowreq_ctx->data
 */
    (* patternStruct_val_ptr ) = rowreq_ctx->data.patternStruct;

    return MFD_SUCCESS;
} /* patternStruct_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternPlanNumber
 * patternPlanNumber is subid 8 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.8
 * Description:
<Definition>
Geçilmesi istenilen plan
		255 değeri plan değişikliği istenmediği anlamına
		gelir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternPlanNumber data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternPlanNumber_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternPlanNumber_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternPlanNumber_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternPlanNumber_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternPlanNumber_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternPlanNumber data.
 * copy (* patternPlanNumber_val_ptr ) from rowreq_ctx->data
 */
    (* patternPlanNumber_val_ptr ) = rowreq_ctx->data.patternPlanNumber;

    return MFD_SUCCESS;
} /* patternPlanNumber_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternSync
 * patternSync is subid 9 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.9
 * Description:
<Definition>
		0: Yeşil dalga uygulanmayacaktır.
		1: Yeşil dalga uygulanacaktır.
		2: Yeşil dalga ile ilgili bir değişiklik olmayacak.
Mevcut duruma devam edilecektir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 2;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternSync data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternSync_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternSync_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternSync_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternSync_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternSync_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternSync data.
 * copy (* patternSync_val_ptr ) from rowreq_ctx->data
 */
    (* patternSync_val_ptr ) = rowreq_ctx->data.patternSync;

    return MFD_SUCCESS;
} /* patternSync_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternOffsetTime
 * patternOffsetTime is subid 10 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.10
 * Description:
<Definition>
		Yeşil dalga ofseti(tenth cinsinden)
		65535 ise değişiklik istenmiyor. Yeşil dalga ofseti bağıl bir değerdir. Referans devre başlangıç anlarına göre ölçülür. Referans başlangıç zamanı cihazların yeşil dalga algoritmalarına göre değişebilir.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternOffsetTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternOffsetTime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternOffsetTime_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternOffsetTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternOffsetTime_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternOffsetTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternOffsetTime data.
 * copy (* patternOffsetTime_val_ptr ) from rowreq_ctx->data
 */
    (* patternOffsetTime_val_ptr ) = rowreq_ctx->data.patternOffsetTime;

    return MFD_SUCCESS;
} /* patternOffsetTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStageCount
 * patternStageCount is subid 11 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.11
 * Description:
<Definition>
		Sinyal planındaki faz sayısı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternStageCount data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStageCount_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternStageCount_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternStageCount_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternStageCount_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternStageCount_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternStageCount data.
 * copy (* patternStageCount_val_ptr ) from rowreq_ctx->data
 */
    (* patternStageCount_val_ptr ) = rowreq_ctx->data.patternStageCount;

    return MFD_SUCCESS;
} /* patternStageCount_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStageTime
 * patternStageTime is subid 12 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.12
 * Description:
<Definition>
Her iki octet(2 byte) bir fazın yeşil süresine denk gelir. (tenth cinsinden)
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the patternStageTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStageTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param patternStageTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by patternStageTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*patternStageTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update patternStageTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
patternStageTime_get( trPatternTable_rowreq_ctx *rowreq_ctx, char **patternStageTime_val_ptr_ptr, size_t *patternStageTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != patternStageTime_val_ptr_ptr) && (NULL != *patternStageTime_val_ptr_ptr));
   netsnmp_assert( NULL != patternStageTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternStageTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternStageTime data.
 * copy (* patternStageTime_val_ptr_ptr ) data and (* patternStageTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for patternStageTime data
     */
    if ((NULL == (* patternStageTime_val_ptr_ptr )) ||
        ((* patternStageTime_val_ptr_len_ptr ) <
         (rowreq_ctx->data.patternStageTime_len* sizeof(rowreq_ctx->data.patternStageTime[0])))) {
        /*
         * allocate space for patternStageTime data
         */
        (* patternStageTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.patternStageTime_len* sizeof(rowreq_ctx->data.patternStageTime[0]));
        if(NULL == (* patternStageTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.patternStageTime)\n");
            return MFD_ERROR;
        }
    }
    (* patternStageTime_val_ptr_len_ptr ) = rowreq_ctx->data.patternStageTime_len* sizeof(rowreq_ctx->data.patternStageTime[0]);
    memcpy( (* patternStageTime_val_ptr_ptr ), rowreq_ctx->data.patternStageTime, rowreq_ctx->data.patternStageTime_len* sizeof(rowreq_ctx->data.patternStageTime[0]) );

    return MFD_SUCCESS;
} /* patternStageTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStageSensorFailureMask
 * patternStageSensorFailureMask is subid 13 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.13
 * Description:
<Definition>
(Adaptif/uyarmalı çalışmada) belirtilen sensörlerde arıza olması durumunda sabit zamanlı çalışmaya dönülür.
Birinci octet: Sensör 1 – 8
İkinci octet : Sensör 9 – 16
.
.
.
	şeklinde devam eder.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the patternStageSensorFailureMask data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStageSensorFailureMask_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param patternStageSensorFailureMask_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by patternStageSensorFailureMask.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*patternStageSensorFailureMask_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update patternStageSensorFailureMask_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
patternStageSensorFailureMask_get( trPatternTable_rowreq_ctx *rowreq_ctx, char **patternStageSensorFailureMask_val_ptr_ptr, size_t *patternStageSensorFailureMask_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != patternStageSensorFailureMask_val_ptr_ptr) && (NULL != *patternStageSensorFailureMask_val_ptr_ptr));
   netsnmp_assert( NULL != patternStageSensorFailureMask_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternStageSensorFailureMask_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternStageSensorFailureMask data.
 * copy (* patternStageSensorFailureMask_val_ptr_ptr ) data and (* patternStageSensorFailureMask_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for patternStageSensorFailureMask data
     */
    if ((NULL == (* patternStageSensorFailureMask_val_ptr_ptr )) ||
        ((* patternStageSensorFailureMask_val_ptr_len_ptr ) <
         (rowreq_ctx->data.patternStageSensorFailureMask_len* sizeof(rowreq_ctx->data.patternStageSensorFailureMask[0])))) {
        /*
         * allocate space for patternStageSensorFailureMask data
         */
        (* patternStageSensorFailureMask_val_ptr_ptr ) = malloc(rowreq_ctx->data.patternStageSensorFailureMask_len* sizeof(rowreq_ctx->data.patternStageSensorFailureMask[0]));
        if(NULL == (* patternStageSensorFailureMask_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.patternStageSensorFailureMask)\n");
            return MFD_ERROR;
        }
    }
    (* patternStageSensorFailureMask_val_ptr_len_ptr ) = rowreq_ctx->data.patternStageSensorFailureMask_len* sizeof(rowreq_ctx->data.patternStageSensorFailureMask[0]);
    memcpy( (* patternStageSensorFailureMask_val_ptr_ptr ), rowreq_ctx->data.patternStageSensorFailureMask, rowreq_ctx->data.patternStageSensorFailureMask_len* sizeof(rowreq_ctx->data.patternStageSensorFailureMask[0]) );

    return MFD_SUCCESS;
} /* patternStageSensorFailureMask_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternStartDate
 * patternStartDate is subid 14 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.14
 * Description:
<Definition>
		Plan değişkliğinin devreye gireceği zaman. 01.01.1970 00:00 (epoch) tarihinden itibaren geçen saniye sayısı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the patternStartDate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternStartDate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternStartDate_get( trPatternTable_rowreq_ctx *rowreq_ctx, u_long * patternStartDate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternStartDate_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternStartDate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternStartDate data.
 * copy (* patternStartDate_val_ptr ) from rowreq_ctx->data
 */
    (* patternStartDate_val_ptr ) = rowreq_ctx->data.patternStartDate;

    return MFD_SUCCESS;
} /* patternStartDate_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternEndDate
 * patternEndDate is subid 15 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.15
 * Description:
<Definition>
		Plan değişikliğinin devre dışı kalacağı zaman. 01.01.1970 00:00 (epoch) tarihinden itibaren geçen saniye sayısı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the patternEndDate data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternEndDate_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternEndDate_get( trPatternTable_rowreq_ctx *rowreq_ctx, u_long * patternEndDate_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternEndDate_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternEndDate_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternEndDate data.
 * copy (* patternEndDate_val_ptr ) from rowreq_ctx->data
 */
    (* patternEndDate_val_ptr ) = rowreq_ctx->data.patternEndDate;

    return MFD_SUCCESS;
} /* patternEndDate_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternGreenwaveCycleTime
 * patternGreenwaveCycleTime is subid 16 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.16
 * Description:
<Definition>

		Yeşil dalga devre süresi(tenth cinsinden)
		65535 ise değiştirilmez.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 65535;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternGreenwaveCycleTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternGreenwaveCycleTime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternGreenwaveCycleTime_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternGreenwaveCycleTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternGreenwaveCycleTime_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveCycleTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternGreenwaveCycleTime data.
 * copy (* patternGreenwaveCycleTime_val_ptr ) from rowreq_ctx->data
 */
    (* patternGreenwaveCycleTime_val_ptr ) = rowreq_ctx->data.patternGreenwaveCycleTime;

    return MFD_SUCCESS;
} /* patternGreenwaveCycleTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternGreenwaveStageId
 * patternGreenwaveStageId is subid 17 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.17
 * Description:
<Definition>
Yeşil dalga faz numarası. Yeşil dalga uygulaması belirtilen faz referans alınarak yapılır.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternGreenwaveStageId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternGreenwaveStageId_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternGreenwaveStageId_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternGreenwaveStageId_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternGreenwaveStageId_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternGreenwaveStageId_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternGreenwaveStageId data.
 * copy (* patternGreenwaveStageId_val_ptr ) from rowreq_ctx->data
 */
    (* patternGreenwaveStageId_val_ptr ) = rowreq_ctx->data.patternGreenwaveStageId;

    return MFD_SUCCESS;
} /* patternGreenwaveStageId_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternGreenWaveReturnStageId
 * patternGreenWaveReturnStageId is subid 18 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.18
 * Description:
<Definition>
return phase
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternGreenWaveReturnStageId data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternGreenWaveReturnStageId_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternGreenWaveReturnStageId_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternGreenWaveReturnStageId_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternGreenWaveReturnStageId_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternGreenWaveReturnStageId_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternGreenWaveReturnStageId data.
 * copy (* patternGreenWaveReturnStageId_val_ptr ) from rowreq_ctx->data
 */
    (* patternGreenWaveReturnStageId_val_ptr ) = rowreq_ctx->data.patternGreenWaveReturnStageId;

    return MFD_SUCCESS;
} /* patternGreenWaveReturnStageId_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternSensorEnable
 * patternSensorEnable is subid 19 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.19
 * Description:
<Definition>
		Sensörleri devreye almak veya devre dışı bırakmak
için kullanılır.
0: Devre dışı
1: Devrede
2: Değişiklik yok.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 2;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternSensorEnable data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternSensorEnable_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternSensorEnable_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternSensorEnable_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternSensorEnable_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternSensorEnable_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternSensorEnable data.
 * copy (* patternSensorEnable_val_ptr ) from rowreq_ctx->data
 */
    (* patternSensorEnable_val_ptr ) = rowreq_ctx->data.patternSensorEnable;

    return MFD_SUCCESS;
} /* patternSensorEnable_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternSensorSupervision
 * patternSensorSupervision is subid 20 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.20
 * Description:
<Definition>
Sensör arıza kontrolünü devreye almak veya devre dışı bırakmak
için kullanılır.
0: Devre dışı
1: Devrede
2: Değişiklik yok.

<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternSensorSupervision data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternSensorSupervision_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternSensorSupervision_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternSensorSupervision_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternSensorSupervision_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternSensorSupervision_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternSensorSupervision data.
 * copy (* patternSensorSupervision_val_ptr ) from rowreq_ctx->data
 */
    (* patternSensorSupervision_val_ptr ) = rowreq_ctx->data.patternSensorSupervision;

    return MFD_SUCCESS;
} /* patternSensorSupervision_get */

/*---------------------------------------------------------------------
 * kgm-ortak::trPatternEntry.patternOutputSupervision
 * patternOutputSupervision is subid 21 of trPatternEntry.
 * Its status is Mandatory, and its access level is ReadWrite.
 * OID: .1.3.6.1.4.1.59873.4.2.1.9.2.1.21
 * Description:
<Definition>
Sinyal çıkışları arıza kontrolünü devreye almak veya devre dışı bırakmak
için kullanılır.
0: Devre dışı
1: Devrede
2: Değişiklik yok.

<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternOutputSupervision data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternOutputSupervision_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternOutputSupervision_get( trPatternTable_rowreq_ctx *rowreq_ctx, long * patternOutputSupervision_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternOutputSupervision_val_ptr );


    DEBUGMSGTL(("verbose:trPatternTable:patternOutputSupervision_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternOutputSupervision data.
 * copy (* patternOutputSupervision_val_ptr ) from rowreq_ctx->data
 */
    (* patternOutputSupervision_val_ptr ) = rowreq_ctx->data.patternOutputSupervision;

    return MFD_SUCCESS;
} /* patternOutputSupervision_get */



/** @} */
