/*
 * Note: this file originally auto-generated by mib2c
 * using mfd-data-get.m2c
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-features.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "signalStateTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement signalStateTable get routines.
 * TODO:240:M: Implement signalStateTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table signalStateTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * kgm-ortak::signalStateTable is subid 2 of signalState.
 * Its status is Mandatory.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2, length: 12
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement signalStateTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param signalStateIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
signalStateTable_indexes_set_tbl_idx(signalStateTable_mib_index *tbl_idx, long signalStateIndex_val)
{
    DEBUGMSGTL(("verbose:signalStateTable:signalStateTable_indexes_set_tbl_idx","called\n"));

    /* signalStateIndex(1)/INTEGER/ASN_INTEGER/long(long)//l/A/w/e/R/d/h */
    tbl_idx->signalStateIndex = signalStateIndex_val;
    

    return MFD_SUCCESS;
} /* signalStateTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
signalStateTable_indexes_set(signalStateTable_rowreq_ctx *rowreq_ctx, long signalStateIndex_val)
{
    DEBUGMSGTL(("verbose:signalStateTable:signalStateTable_indexes_set","called\n"));

    if(MFD_SUCCESS != signalStateTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , signalStateIndex_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != signalStateTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* signalStateTable_indexes_set */


/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStatePatternNo
 * signalStatePatternNo is subid 2 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.2
 * Description:
<Definition> Sinyal durum tablosu 
patern numara bilgisi. 
 
<Object Identifier> 1.3.6.1.4.1.59873.4.2.1.1.8.1.2
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStatePatternNo data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStatePatternNo_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStatePatternNo_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStatePatternNo_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStatePatternNo_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStatePatternNo_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStatePatternNo data.
 * copy (* signalStatePatternNo_val_ptr ) from rowreq_ctx->data
 */
    (* signalStatePatternNo_val_ptr ) = rowreq_ctx->data.signalStatePatternNo;

    return MFD_SUCCESS;
} /* signalStatePatternNo_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateExecMode
 * signalStateExecMode is subid 3 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.3
 * Description:
<Definition>
		Hangi modda olduğu bilgisini içerir.
		Cihaz program modunda ise detayda hangi modda çalıştığı bilgisi signalStatePlanMode nesnesinden okunur.
		None (0)
		Init(1): Cihaz yeni açıldı henüz çıkışları sürmeye
		başlamadı
		InitialFlash(2): Cihaz yeni açılmış veya yapı değişikliği olmuş ve başlangıç flaşı yapıyor.
		Program(3): Cihaz haftalık plandaki düzene göre çalışıyor.
		Flash(4): Cihaz flaş moduna zorlanmış
		FailFlash(5): Cihaz arızi bir durumdan dolayı flaş
		moduna geçmiş
		AllYellow(6): Tüm çıkışlar sarı
		AllRed(7): Tüm çıkışlar kırmızı
		AllDark(8): Tüm çıkışlar sönük
		TestOutputs(9): Çıkışların lambalara doğru bir şekilde bağlanıp bağlanmadığını kontrol etmek için sıra ile her bir çıkışa yeşil, sarı, kırmızı, kırmızı sarı renklerinin verilmesidir.
		ProgramError(10): Sinyal programcısı tarafından yüklenen sinyal planında bir hata olması durumunda geçilen mod.
		TestSignalPlan(11): Bu modda sinyal çıkışları kapalıdır. Diğer her şey program modunda çalışmaktadır.

	<Object Identifier> KGM OID
	<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 12. Values:  none(0), init(1), initialFlash(2), program(3), flash(4), failFlash(5), allYellow(6), allRed(7), allDark(8), testOutputs(9), programError(10), testSignalPlan(11)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the signalStateExecMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateExecMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateExecMode_get( signalStateTable_rowreq_ctx *rowreq_ctx, u_long * signalStateExecMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateExecMode_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateExecMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateExecMode data.
 * copy (* signalStateExecMode_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateExecMode_val_ptr ) = rowreq_ctx->data.signalStateExecMode;

    return MFD_SUCCESS;
} /* signalStateExecMode_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStatePlanMode
 * signalStatePlanMode is subid 4 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.4
 * Description:
<Definition>
		fixedPlan(0): Multi Plan(sabit süreli), sensörler devre dışıdır. Faz süreleri haftalık planda belirlenen sürelere göre değişmektedir.
		halfActuated(1): Kavşağın bazı kollarında sensör bulunmakta(loop dedektör, yaya butonu vb.) bazı kollarında ise sensör bulunmayabilmektedir. Sinyal planındaki bazı fazlar istenirse pas geçilebilmektedir.
		fullyActuated(2): Kavşağın bütün kollarında sensör bulunmaktadır. Sinyal planındaki bütün fazlar açılmakta ve talep olması durumunda max süreye kadar çalıştırılmaktadır.
		centralAdaptive(3): Bu modda plan süreleri merkezi bir program tarafından üretilmekte ve cihaz tarafından uygulanmaktadır.
		flashing(4): Flaşlı çalışma(Gece flaşı gibi)
		dark(5): Çıkışların kapalı olduğu mod(Sadece belli saatlerde işletilen kavşakların olması durumu)

	<Object Identifier> KGM OID
	<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 * Enum range: 6. Values:  fixedPlan(0), halfActuated(1), fullyActuated(2), centralAdaptive(3), flashing(4), dark(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the signalStatePlanMode data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStatePlanMode_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStatePlanMode_get( signalStateTable_rowreq_ctx *rowreq_ctx, u_long * signalStatePlanMode_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStatePlanMode_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStatePlanMode_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStatePlanMode data.
 * copy (* signalStatePlanMode_val_ptr ) from rowreq_ctx->data
 */
    (* signalStatePlanMode_val_ptr ) = rowreq_ctx->data.signalStatePlanMode;

    return MFD_SUCCESS;
} /* signalStatePlanMode_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateStructure
 * signalStateStructure is subid 5 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.5
 * Description:
<Definition>
		Çalışmakta olan yapı
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStateStructure data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateStructure_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateStructure_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStateStructure_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateStructure_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateStructure_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateStructure data.
 * copy (* signalStateStructure_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateStructure_val_ptr ) = rowreq_ctx->data.signalStateStructure;

    return MFD_SUCCESS;
} /* signalStateStructure_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStatePlan
 * signalStatePlan is subid 6 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.6
 * Description:
<Definition>
		Çalışmakta olan plan
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStatePlan data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStatePlan_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStatePlan_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStatePlan_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStatePlan_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStatePlan_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStatePlan data.
 * copy (* signalStatePlan_val_ptr ) from rowreq_ctx->data
 */
    (* signalStatePlan_val_ptr ) = rowreq_ctx->data.signalStatePlan;

    return MFD_SUCCESS;
} /* signalStatePlan_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateStage
 * signalStateStage is subid 7 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.7
 * Description:
<Definition>
		Türkiyedeki faza karşılıktır.
		Çalışmakta olan faz veya fazlar.
	<Object Identifier> KGM OID
	<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the signalStateStage data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateStage_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param signalStateStage_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by signalStateStage.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*signalStateStage_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update signalStateStage_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
signalStateStage_get( signalStateTable_rowreq_ctx *rowreq_ctx, char **signalStateStage_val_ptr_ptr, size_t *signalStateStage_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != signalStateStage_val_ptr_ptr) && (NULL != *signalStateStage_val_ptr_ptr));
   netsnmp_assert( NULL != signalStateStage_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateStage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateStage data.
 * copy (* signalStateStage_val_ptr_ptr ) data and (* signalStateStage_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for signalStateStage data
     */
    if ((NULL == (* signalStateStage_val_ptr_ptr )) ||
        ((* signalStateStage_val_ptr_len_ptr ) <
         (rowreq_ctx->data.signalStateStage_len* sizeof(rowreq_ctx->data.signalStateStage[0])))) {
        /*
         * allocate space for signalStateStage data
         */
        (* signalStateStage_val_ptr_ptr ) = malloc(rowreq_ctx->data.signalStateStage_len* sizeof(rowreq_ctx->data.signalStateStage[0]));
        if(NULL == (* signalStateStage_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.signalStateStage)\n");
            return MFD_ERROR;
        }
    }
    (* signalStateStage_val_ptr_len_ptr ) = rowreq_ctx->data.signalStateStage_len* sizeof(rowreq_ctx->data.signalStateStage[0]);
    memcpy( (* signalStateStage_val_ptr_ptr ), rowreq_ctx->data.signalStateStage, rowreq_ctx->data.signalStateStage_len* sizeof(rowreq_ctx->data.signalStateStage[0]) );

    return MFD_SUCCESS;
} /* signalStateStage_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateNextStage
 * signalStateNextStage is subid 8 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.8
 * Description:
<Definition>
		Bir sonraki fazı veya fazları ifade eder.
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the signalStateNextStage data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateNextStage_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param signalStateNextStage_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by signalStateNextStage.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*signalStateNextStage_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update signalStateNextStage_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
signalStateNextStage_get( signalStateTable_rowreq_ctx *rowreq_ctx, char **signalStateNextStage_val_ptr_ptr, size_t *signalStateNextStage_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != signalStateNextStage_val_ptr_ptr) && (NULL != *signalStateNextStage_val_ptr_ptr));
   netsnmp_assert( NULL != signalStateNextStage_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateNextStage_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateNextStage data.
 * copy (* signalStateNextStage_val_ptr_ptr ) data and (* signalStateNextStage_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for signalStateNextStage data
     */
    if ((NULL == (* signalStateNextStage_val_ptr_ptr )) ||
        ((* signalStateNextStage_val_ptr_len_ptr ) <
         (rowreq_ctx->data.signalStateNextStage_len* sizeof(rowreq_ctx->data.signalStateNextStage[0])))) {
        /*
         * allocate space for signalStateNextStage data
         */
        (* signalStateNextStage_val_ptr_ptr ) = malloc(rowreq_ctx->data.signalStateNextStage_len* sizeof(rowreq_ctx->data.signalStateNextStage[0]));
        if(NULL == (* signalStateNextStage_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.signalStateNextStage)\n");
            return MFD_ERROR;
        }
    }
    (* signalStateNextStage_val_ptr_len_ptr ) = rowreq_ctx->data.signalStateNextStage_len* sizeof(rowreq_ctx->data.signalStateNextStage[0]);
    memcpy( (* signalStateNextStage_val_ptr_ptr ), rowreq_ctx->data.signalStateNextStage, rowreq_ctx->data.signalStateNextStage_len* sizeof(rowreq_ctx->data.signalStateNextStage[0]) );

    return MFD_SUCCESS;
} /* signalStateNextStage_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateStep
 * signalStateStep is subid 9 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.9
 * Description:
<Definition>
		Çalışmakta olan adım
		0 yada 255  = Uygulanamaz
	<Object Identifier> KGM OID
	<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  1 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStateStep data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateStep_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateStep_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStateStep_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateStep_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateStep_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateStep data.
 * copy (* signalStateStep_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateStep_val_ptr ) = rowreq_ctx->data.signalStateStep;

    return MFD_SUCCESS;
} /* signalStateStep_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateTransitionFlag
 * signalStateTransitionFlag is subid 10 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.10
 * Description:
<Definition>
		Çalışmakta olan adımın geçiş adımı olup olmadığı bilgisini içerir.
 <Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStateTransitionFlag data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateTransitionFlag_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateTransitionFlag_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStateTransitionFlag_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateTransitionFlag_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateTransitionFlag_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateTransitionFlag data.
 * copy (* signalStateTransitionFlag_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateTransitionFlag_val_ptr ) = rowreq_ctx->data.signalStateTransitionFlag;

    return MFD_SUCCESS;
} /* signalStateTransitionFlag_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateTransitionStep
 * signalStateTransitionStep is subid 11 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.11
 * Description:
<Definition>
		Geçiş adımı numarası
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStateTransitionStep data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateTransitionStep_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateTransitionStep_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStateTransitionStep_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateTransitionStep_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateTransitionStep_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateTransitionStep data.
 * copy (* signalStateTransitionStep_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateTransitionStep_val_ptr ) = rowreq_ctx->data.signalStateTransitionStep;

    return MFD_SUCCESS;
} /* signalStateTransitionStep_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateElapsedTime
 * signalStateElapsedTime is subid 12 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.12
 * Description:
<Definition>
	Mevcut adım veya adımların başladığı andan itibaren geçen süre
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the signalStateElapsedTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateElapsedTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param signalStateElapsedTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by signalStateElapsedTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*signalStateElapsedTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update signalStateElapsedTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
signalStateElapsedTime_get( signalStateTable_rowreq_ctx *rowreq_ctx, char **signalStateElapsedTime_val_ptr_ptr, size_t *signalStateElapsedTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != signalStateElapsedTime_val_ptr_ptr) && (NULL != *signalStateElapsedTime_val_ptr_ptr));
   netsnmp_assert( NULL != signalStateElapsedTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateElapsedTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateElapsedTime data.
 * copy (* signalStateElapsedTime_val_ptr_ptr ) data and (* signalStateElapsedTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for signalStateElapsedTime data
     */
    if ((NULL == (* signalStateElapsedTime_val_ptr_ptr )) ||
        ((* signalStateElapsedTime_val_ptr_len_ptr ) <
         (rowreq_ctx->data.signalStateElapsedTime_len* sizeof(rowreq_ctx->data.signalStateElapsedTime[0])))) {
        /*
         * allocate space for signalStateElapsedTime data
         */
        (* signalStateElapsedTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.signalStateElapsedTime_len* sizeof(rowreq_ctx->data.signalStateElapsedTime[0]));
        if(NULL == (* signalStateElapsedTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.signalStateElapsedTime)\n");
            return MFD_ERROR;
        }
    }
    (* signalStateElapsedTime_val_ptr_len_ptr ) = rowreq_ctx->data.signalStateElapsedTime_len* sizeof(rowreq_ctx->data.signalStateElapsedTime[0]);
    memcpy( (* signalStateElapsedTime_val_ptr_ptr ), rowreq_ctx->data.signalStateElapsedTime, rowreq_ctx->data.signalStateElapsedTime_len* sizeof(rowreq_ctx->data.signalStateElapsedTime[0]) );

    return MFD_SUCCESS;
} /* signalStateElapsedTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateRemainingTime
 * signalStateRemainingTime is subid 13 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.13
 * Description:
<Definition>
		Mevcut adım veya adımların kalan süresi
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is OCTETSTR (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.
 */
/**
 * Extract the current value of the signalStateRemainingTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateRemainingTime_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param signalStateRemainingTime_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by signalStateRemainingTime.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*signalStateRemainingTime_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update signalStateRemainingTime_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
signalStateRemainingTime_get( signalStateTable_rowreq_ctx *rowreq_ctx, char **signalStateRemainingTime_val_ptr_ptr, size_t *signalStateRemainingTime_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != signalStateRemainingTime_val_ptr_ptr) && (NULL != *signalStateRemainingTime_val_ptr_ptr));
   netsnmp_assert( NULL != signalStateRemainingTime_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateRemainingTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateRemainingTime data.
 * copy (* signalStateRemainingTime_val_ptr_ptr ) data and (* signalStateRemainingTime_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for signalStateRemainingTime data
     */
    if ((NULL == (* signalStateRemainingTime_val_ptr_ptr )) ||
        ((* signalStateRemainingTime_val_ptr_len_ptr ) <
         (rowreq_ctx->data.signalStateRemainingTime_len* sizeof(rowreq_ctx->data.signalStateRemainingTime[0])))) {
        /*
         * allocate space for signalStateRemainingTime data
         */
        (* signalStateRemainingTime_val_ptr_ptr ) = malloc(rowreq_ctx->data.signalStateRemainingTime_len* sizeof(rowreq_ctx->data.signalStateRemainingTime[0]));
        if(NULL == (* signalStateRemainingTime_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory (rowreq_ctx->data.signalStateRemainingTime)\n");
            return MFD_ERROR;
        }
    }
    (* signalStateRemainingTime_val_ptr_len_ptr ) = rowreq_ctx->data.signalStateRemainingTime_len* sizeof(rowreq_ctx->data.signalStateRemainingTime[0]);
    memcpy( (* signalStateRemainingTime_val_ptr_ptr ), rowreq_ctx->data.signalStateRemainingTime, rowreq_ctx->data.signalStateRemainingTime_len* sizeof(rowreq_ctx->data.signalStateRemainingTime[0]) );

    return MFD_SUCCESS;
} /* signalStateRemainingTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateStepTime
 * signalStateStepTime is subid 14 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.14
 * Description:
<Definition>
		Adımın toplam süresi
		0 yada 255  = Uygulanamaz
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStateStepTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateStepTime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateStepTime_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStateStepTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateStepTime_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateStepTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateStepTime data.
 * copy (* signalStateStepTime_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateStepTime_val_ptr ) = rowreq_ctx->data.signalStateStepTime;

    return MFD_SUCCESS;
} /* signalStateStepTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalStateCycleTime
 * signalStateCycleTime is subid 15 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.15
 * Description:
<Definition>
		Devre süresi
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the signalStateCycleTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalStateCycleTime_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalStateCycleTime_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * signalStateCycleTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalStateCycleTime_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalStateCycleTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalStateCycleTime data.
 * copy (* signalStateCycleTime_val_ptr ) from rowreq_ctx->data
 */
    (* signalStateCycleTime_val_ptr ) = rowreq_ctx->data.signalStateCycleTime;

    return MFD_SUCCESS;
} /* signalStateCycleTime_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.patternTimeToNextCycle
 * patternTimeToNextCycle is subid 16 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.16
 * Description:
<Definition>
		Yeşil dalga durumunda sonraki peryodun başlangıcına
		kalan süre(sn).
<Object Identifier> KGM OID
<Unit>  
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   0
 *
 * Ranges:  0 - 255;
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the patternTimeToNextCycle data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param patternTimeToNextCycle_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
patternTimeToNextCycle_get( signalStateTable_rowreq_ctx *rowreq_ctx, long * patternTimeToNextCycle_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != patternTimeToNextCycle_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:patternTimeToNextCycle_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the patternTimeToNextCycle data.
 * copy (* patternTimeToNextCycle_val_ptr ) from rowreq_ctx->data
 */
    (* patternTimeToNextCycle_val_ptr ) = rowreq_ctx->data.patternTimeToNextCycle;

    return MFD_SUCCESS;
} /* patternTimeToNextCycle_get */

/*---------------------------------------------------------------------
 * kgm-ortak::signalStateEntry.signalPlanLastChangeTime
 * signalPlanLastChangeTime is subid 17 of signalStateEntry.
 * Its status is Mandatory, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.59873.4.2.1.4.2.1.17
 * Description:
<Definition>

<Object Identifier> KGM OID
<Unit> second
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the signalPlanLastChangeTime data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param signalPlanLastChangeTime_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
signalPlanLastChangeTime_get( signalStateTable_rowreq_ctx *rowreq_ctx, u_long * signalPlanLastChangeTime_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != signalPlanLastChangeTime_val_ptr );


    DEBUGMSGTL(("verbose:signalStateTable:signalPlanLastChangeTime_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the signalPlanLastChangeTime data.
 * copy (* signalPlanLastChangeTime_val_ptr ) from rowreq_ctx->data
 */
    (* signalPlanLastChangeTime_val_ptr ) = rowreq_ctx->data.signalPlanLastChangeTime;

    return MFD_SUCCESS;
} /* signalPlanLastChangeTime_get */



/** @} */
